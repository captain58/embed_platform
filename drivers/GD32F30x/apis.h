/****************************************Copyright (c)**************************************************
**                                  ________科技有限公司
**                                          开发部
**
**
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名: OS_Ext.h
**创   建   人: yzy
**最后修改日期: 2011年1月3日
**描        述: SmartAlly2.0的操作系统公开函数名定位的头文件
**注        意:
********************************************************************************************************/
#ifndef _APIS_H_
#define _APIS_H_


#ifndef EXT_APIS
    #define EXT_APIS extern
#endif



typedef struct
{
#if SYS_FIFO_EN > 0
    /************************************************************************
     * @function: SYS_FIFO_Create
     * @描述: 创建一个FIFO
     * 
     * @参数: 
     * @param: type 创建的FIFO的数据单元的类型
     * @param: fifo 需要创建的fifo
     * @param: buffer 需要创建的FIFO的数据的缓存位置
     * @param: num 需要创建的FIFO的数据单元的长度(字节数)
     * 
     * @返回: 
     * @return: uint8  
     * @说明: 
     * @作者: yzy (2013/6/9)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint8 (*FIFO_Create)(size_array type, FIFO* fifo, void* buffer, uint16 length);

    /************************************************************************
     * @function: SYS_FIFO_Enqueue
     * @描述: 将一个数据排到队列里面去
     * 
     * @参数: 
     * @param: fifo 需要入队的fifo
     * @param: content 入队的内容
     * 
     * @返回: 
     * @return: uint8  
     * @说明: 
     * @作者: yzy (2013/6/9)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint8 (*FIFO_Enqueue)(FIFO* fifo, void* content);


    /************************************************************************
     * @function: SYS_FIFO_Dequeue
     * @描述: 从FIFO里面获取一个数据,这个数据不再存在FIFO里面
     * 
     * @参数: 
     * @param: fifo 需要出队的fifo, 注意这个函数本身是进程安全的,但是获取的内容则不一定了.
     * 
     * @返回: 
     * @return: void*  __NULL表示队列空,其它:出队数据的内容的地址
     * @说明: 
     * @作者: yzy (2013/6/9)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void* (*FIFO_Dequeue)(FIFO* fifo);


    /************************************************************************
     * @function: SYS_FIFO_Get
     * @描述: 从FIFO里面获取一个数据,这个数据不再存在FIFO里面
     * 
     * @参数: 
     * @param: fifo 需要出队的fifo
     * @param: content 获取的数据保存的位置,这个函数是进程安全的.
     * 
     * @返回: 
     * @return: uint8  成功/失败
     * @说明: 
     * @作者: yzy (2013/6/9)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint8 (*FIFO_Get)(FIFO* fifo, void* content);

    /************************************************************************
     * @function: SYS_FIFO_Peek
     * @描述: 从FIFO里面获取一个数据,这个数据还在FIFO里面注意这个函数本身是进程安全的,但是获取的内容则不一定了.
     * 
     * @参数: 
     * @param: fifo 需要获取数据的fifo
     * 
     * @返回: 
     * @return: void*  __NULL表示队列空   其它:获取数据的内容的地址
     * @说明: 
     * @作者: yzy (2013/6/9)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void* (*FIFO_Peek)(FIFO* fifo);

    /************************************************************************
     * @function: SYS_FIFO_Clear
     * @描述: 清除FIFO
     * 
     * @参数: 
     * @param: fifo 需要清除数据的fifo
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/6/9)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void (*FIFO_Clear)(FIFO* fifo);

#endif

#if SYS_LIFO_EN > 0
    uint8 (*LIFO_Create)(size_array, LIFO*, void*, uint16);
    uint8 (*LIFO_Push)(LIFO*, void*);
    void* (*LIFO_Pop)(LIFO*);
    uint8 (*LIFO_Get)(LIFO*, void*);
    void* (*LIFO_Peek)(LIFO*);
    void (*LIFO_Clear)(LIFO*);
#endif

#if SYS_ARRAY_EN > 0
    uint8 (*Array_Create)(size_array,ARRAY*, void*, uint16);
    uint8 (*Array_Add)(ARRAY*, void*);
    uint8 (*Array_Remove)(ARRAY*, uint16);
    void* (*Array_Get)(ARRAY*, uint16);
    uint8 (*Array_Set)(ARRAY*, uint16, void*);
    void (*Array_Clear)(ARRAY*);
#endif
}_F_ARRAY;

EXT_APIS const _F_ARRAY gs_Array;







//	#if SYS_CALCLIB_EN > 0
//	typedef struct
//	{
//	    /************************************************************************
//	     * @function: MoveBuffer
//	     * @描述: 移动缓存值
//	     * 
//	     * @参数: 
//	     * @param: sbuff 源地址
//	     * @param: tbuff 目标地址
//	     * @param: length 移动的字节数
//	     * 
//	     * @返回: 
//	     * @return: void  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*MoveBuffer)(uint8* sbuff, uint8* tbuff, uint32 length);
//	
//	    /************************************************************************
//	     * @function: InvBuffer
//	     * @描述: 字节翻转
//	     * 
//	     * @参数: 
//	     * @param: buff 要字节翻转的缓存
//	     * @param: length 待翻转的字节数
//	     * 
//	     * @返回: 
//	     * @return: void  
//	     * @说明: 将一个缓存中的字节的顺序进行反转。
//	     *         比如buff[0] = 0x12, buff[1] = 0x34, buff[2] = 0x56,
//	     *         buff[3] = 0x78，那么反转后的结果为buff[0] = 0x78,
//	     *         buff[1] = 0x56, buff[2] = 0x34, buff[3] = 0x12
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*InvBuffer)(uint8* buff, uint32 length);
//	
//	    /************************************************************************
//	     * @function: CmpBuffer
//	     * @描述: 比较缓存是否一致
//	     * 
//	     * @参数: 
//	     * @param: buff1 比较的缓存1
//	     * @param: buff2 比较的缓存2
//	     * @param: length 比较的长度
//	     * 
//	     * @返回: 
//	     * @return: uint8 
//	     *      0: 两个缓存的内容一样
//	     *      1: 两个缓存的内容不一样，buff1 > buff2
//	     *      2: 两个缓存的内容不一样，buff1 < buff2
//	     * @说明: 比较两个缓存里面的内容。从每个缓存的第一个字节开始比较，
//	     *        直到不一样之后退出，不一样的那两个字节的大小代表了两个缓存的大小。
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*CmpBuffer)(uint8* buff1, uint8* buff2, uint32 length);
//	
//	    /************************************************************************
//	     * @function: ClearBuffer
//	     * @描述: 清零缓存
//	     * 
//	     * @参数: 
//	     * @param: buff 要清零的缓存
//	     * @param: length 要清零的字节数
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*ClearBuffer)(uint8* buff, uint32 length);
//	
//	    /************************************************************************
//	     * @function: memset
//	     * @描述: 置数缓存
//	     * 
//	     * @参数: 
//	     * @param: buffer 要置数的缓存
//	     * @param: val 要置数的值
//	     * @param: length 要置数的字节数
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*memset)(void* buffer, uint8 val, uint32 length);
//	
//	    /************************************************************************
//	     * @function: strlen
//	     * @描述: 计算字符串的长度
//	     * 
//	     * @参数: 
//	     * @param: str 字符串
//	     * 
//	     * @返回: 
//	     * @return: uint16  字符串的长度
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*strlen)(string str);
//	
//	    /************************************************************************
//	     * @function: memcpy
//	     * @描述: 拷贝缓存
//	     * 
//	     * @参数: 
//	     * @param: tb 源地址
//	     * @param: sb 目标地址
//	     * @param: length 移动的字节数
//	     * @返回: 
//	     * @说明: 功能同 MoveBuffer()
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*memcpy)(void* tb, void* sb, uint32 length);
//	
//	    /************************************************************************
//	     * @function: strcpy
//	     * @描述: 拷贝字符串
//	     * 
//	     * @参数: 
//	     * @param: str1 目标字符串
//	     * @param: str2 源字符串
//	     * 
//	     * @返回: 
//	     * @return: uint16 字符串的长度
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*strcpy)(string str1, string str2);
//	
//	    /************************************************************************
//	     * @function: Divu8
//	     * @描述: 两个8位数相除
//	     * 
//	     * @参数: 
//	     * @param: bediv 被除数
//	     * @param: div 除数
//	     * 
//	     * @返回: 
//	     * @return: Word16  商和余数
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    Word16 (*Divu8)(uint8 bediv, uint8 div);
//	
//	    /************************************************************************
//	     * @function: Divu16
//	     * @描述: 两个16位数相除
//	     * 
//	     * @参数: 
//	     * @param: bediv 被除数
//	     * @param: div 除数
//	     * 
//	     * @返回: 
//	     * @return: Word32  商和余数
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    Word32 (*Divu16)(uint16 bediv, uint16 div);
//	
//	    /************************************************************************
//	     * @function: ByteToInt
//	     * @描述: 将两字节的数据转换成一个16位的数
//	     * 
//	     * @参数: 
//	     * @param: byte 存放要转换的两个字节的缓存
//	     * 
//	     * @返回: 
//	     * @return: uint16  两个字节转换成16位数之后的结果
//	     * @说明: 比如byte[0] = 0x03, byte[1] = 0x02那么转换后的结果为0x0203
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*ByteToInt)(uint8* byte);
//	
//	    /************************************************************************
//	     * @function: ByteToLong
//	     * @描述: 四个字节转换成32位数
//	     * 
//	     * @参数: 
//	     * @param: byte 存放要转换的四个字节的缓存
//	     * 
//	     * @返回: 
//	     * @return: uint32  四个字节转换成32位数之后的结果
//	     * @说明: 比如byte[0] = 0x03, byte[1] = 0x02,
//	     *         byte[2] = 0x04, byte[3] = 0x05，
//	     *         那么转换后的结果为0x05040203
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*ByteToLong)(uint8* byte);
//	
//	    /************************************************************************
//	     * @function: ByteToInt24
//	     * @描述: 三个字节转换成24位数
//	     * 
//	     * @参数: 
//	     * @param: byte 存放要转换的三个字节的缓存
//	     * 
//	     * @返回: 
//	     * @return: uint32  三个字节转换成24位数之后的结果
//	     * @说明: 比如byte[0] = 0x03, byte[1] = 0x02, byte[2] = 0x04，
//	     *        那么转换后的结果为0x040203
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*ByteToInt24)(uint8* byte);
//	
//	    /************************************************************************
//	     * @function: IntToByte
//	     * @描述: 类型转换
//	     * 
//	     * @参数: 
//	     * @param: byte 存放转换后的两个字节的缓存
//	     * @param: value 需要转换的值
//	     * @返回: 
//	     * @说明: value = 0x0102,那么转换之后的结果为byte[0]=0x02, byte[1] = 0x01
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*IntToByte)(uint8* byte, uint16 value);
//	
//	    /************************************************************************
//	     * @function: LongToByte
//	     * @描述: 类型转换
//	     * 
//	     * @参数: 
//	     * @param: byte 存放转换后的四个字节的缓存
//	     * @param: value 需要转换的值
//	     * @返回: 
//	     * @说明: 比如value = 0x01020304,那么转换之后的结果为byte[0]=0x04,
//	     *        byte[1] = 0x03，byte[2] = 0x02, byte[3] = 0x01
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*LongToByte)(uint8* byte,  uint32 value);
//	
//	    /************************************************************************
//	     * @function: Int24ToByte
//	     * @描述: 类型转换
//	     * 
//	     * @参数: 
//	     * @param: byte 存放转换后的四个字节的缓存
//	     * @param: value 需要转换的值
//	     * @返回: 
//	     * @说明: 比如value = 0x010203,那么转换之后的结果为byte[0]=0x03,
//	     *        byte[1] = 0x02，byte[2] = 0x01
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*Int24ToByte)(uint8* byte,  uint32 value);
//	
//	    /************************************************************************
//	     * @function: ByteBcdToHex
//	     * @描述: 单字节BCD转换成HEX
//	     * 
//	     * @参数: 
//	     * @param: bcd 要转换的Bcd码
//	     * 
//	     * @返回: 
//	     * @return: uint8  将BCD码转换成HEX之后的结果
//	     * @说明: 比如输入0x12,输出12
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*ByteBcdToHex)(uint8 bcd);
//	
//	    /************************************************************************
//	     * @function: ByteArrayBcdToHex
//	     * @描述: 多个字节BCD转换成HEX
//	     * 
//	     * @参数: 
//	     * @param: bcdary 要转换的Bcd数组
//	     * @param: hexary 输出的hex数组缓存
//	     * @param: len 要转换的字节数
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*ByteArrayBcdToHex)(uint8* bcdary, uint8* hexary, uint32 len);
//	
//	    /************************************************************************
//	     * @function: IntBcdToHex
//	     * @描述: 双字节BCD转换成HEX
//	     * 
//	     * @参数: 
//	     * @param: bcd 要转换的Bcd码
//	     * 
//	     * @返回: 
//	     * @return: uint16  将BCD码转换成HEX之后的结果
//	     * @说明: 输入 0x1234,输出 1234
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*IntBcdToHex)(uint16 bcd);
//	
//	    /************************************************************************
//	     * @function: LongBcdToHex
//	     * @描述: 4字节BCD转换成HEX
//	     * 
//	     * @参数: 
//	     * @param: bcd 要转换的Bcd码
//	     * 
//	     * @返回: 
//	     * @return: uint32  将BCD码转换成HEX之后的结果
//	     * @说明: 输入 0x12345678,输出 12345678
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*LongBcdToHex)(uint32 bcd);
//	
//	    /************************************************************************
//	     * @function: ByteHexToBcd
//	     * @描述: 单字节HEX转换成BCD
//	     * 
//	     * @参数: 
//	     * @param: hex 要转换的hex码 (hex < 100)
//	     * 
//	     * @返回: 
//	     * @return: uint8  将hex码转换成bcd之后的结果
//	     * @说明: 比如hex = 0x12, 那么转换后的结果为0x18
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*ByteHexToBcd)(uint8 hex);
//	
//	    /************************************************************************
//	     * @function: ByteArrayHexToBcd
//	     * @描述: 多字节HEX转换成HEX
//	     * 
//	     * @参数: 
//	     * @param: hexary 需要转换的数据
//	     * @param: bcdary 转换好的字节数组
//	     * @param: len 需要转换的数据的长度
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*ByteArrayHexToBcd)(uint8* hexary, uint8* bcdary, uint32 len);
//	
//	    /************************************************************************
//	     * @function: IntHexToBcd
//	     * @描述: 双字节HEX转换成BCD
//	     * 
//	     * @参数: 
//	     * @param: hex 要转换的hex码(hex < 10000)
//	     * 
//	     * @返回: 
//	     * @return: uint16  将hex码转换成bcd之后的结果
//	     * @说明: 输入 1234 ,输出 0x1234 
//	     *	      采用模拟除以100的方法来进行转换
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*IntHexToBcd)(uint16 hex);
//	
//	    /************************************************************************
//	     * @function: LongHexToBcd
//	     * @描述: 4字节HEX转换成BCD
//	     * 
//	     * @参数: 
//	     * @param: hex 要转换的hex码(hex < 100000000)
//	     * 
//	     * @返回: 
//	     * @return: uint32  将hex码转换成bcd之后的结果
//	     * @说明: 输入 1234567 输出 0x1234567
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*LongHexToBcd)(uint32 hex);
//	
//	    /************************************************************************
//	     * @function: BcdToHex
//	     * @描述: 将指定字节数的BCD码转换成指定字节数的HEX码
//	     * 
//	     * @参数: 
//	     * @param: bcd 要转换的BCD码的存放位置
//	     * @param: hex 转换后的HEX码存放的位置
//	     * @param: nbcd 要转换的BCD码的字节数(<=5)
//	     * @param: nhex 转换后的HEX码的字节数(<=4)
//	     * @返回: 
//	     * @说明: 比如bcd[0] = 0x55, bcd[1] = 0x02, nbcd = 2, nhex = 1,
//	     *        那么转换后的结果为 hex[0] = 0xff（bcd 可以等于 hex）
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*BcdToHex)(uint8* bcd, uint8* hex, uint8 nbcd, uint8 nhex);
//	
//	    /************************************************************************
//	     * @function: HexToBcd
//	     * @描述: 将指定字节数的hex码转换成指定字节数的BCD码
//	     * 
//	     * @参数: 
//	     * @param: bcd 转换后的BCD码的存放位置
//	     * @param: hex 要转换的HEX码存放的位置
//	     * @param: nbcd 转换后的BCD码的字节数 (<=5)
//	     * @param: nhex 要转换的HEX码的字节数 (<=4)
//	     * @返回: 
//	     * @说明: 比如hex[0] = 255, nhex = 1, nbcd =2, 那么转换后的结果为
//	     *          Bcd[0] = 0x55, bcd[1] = 0x02
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*HexToBcd)(uint8* bcd, uint32 hex, uint8 nbcd, uint8 nhex);
//	
//	    /************************************************************************
//	     * @function: IsHexChar
//	     * @描述: 判断ch是否属于合法的字符格式的hex码
//	     * 
//	     * @参数: 
//	     * @param: ch 需要判断的字符
//	     * 
//	     * @返回: 
//	     * @return: uint8  true: ch是'0'-'9','A'-'F','a'-'f'中的成员
//	     *                false: ch不是'0'-'9','A'-'F','a'-'f'中的成员
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*IsHexChar)(uint8 ch);
//	    
//	    /************************************************************************
//	     * @function: IsBcd
//	     * @描述: 判断是否属于合法的压缩型的BCD码
//	     * 
//	     * @参数: 
//	     * @param: bcd 需要判断的字符
//	     * 
//	     * @返回: 
//	     * @return: uint8  true
//	     *                false
//	     * @说明: 比如bcd=0xA5,返回false,bcd=0x55,返回true
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*IsBcd)(uint32 bcd);
//	
//	    /************************************************************************
//	     * @function: IsBcdChar
//	     * @描述: 判断ch是否属于合法的字符格式的BCD码
//	     * 
//	     * @参数: 
//	     * @param: ch 需要判断的字符
//	     * 
//	     * @返回: 
//	     * @return: uint8  true: ch是'0'-'9'中的成员
//	     *                false: ch不是'0'-'9'中的成员
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*IsBcdChar)(uint8 ch);
//	
//	    /************************************************************************
//	     * @function: HexCharToValue
//	     * @描述: 数值转换
//	     * 
//	     * @参数: 
//	     * @param: ch 需要转换的字符
//	     * 
//	     * @返回: 
//	     * @return: uint8  Ch如果是'0'-'9','A'-'F','a'-'f'中的成员那么输出其转换后的值，
//	     *                 否则输出0xFF表示无法转换
//	     * @说明: 比如ch = 'a', 那么转换后是0x0A, 如果ch = 0x01,那么将返回0xff
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*HexCharToValue)(uint8 ch);
//	
//	    /************************************************************************
//	     * @function: ValueToHexChar
//	     * @描述: HexCharToValue的反运算
//	     * 
//	     * @参数: 
//	     * @param: val 要转换的值.范围0-0x0f 
//	     * @param: iscap 输出的ascii是否为大写 
//	     * 
//	     * @返回: 
//	     * @return: uint8  0xFF:无法转换 
//	     *         如val=11, 若iscap为真则输出'B';为假,则输出'b'.
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*ValueToHexChar)(uint8 val, uint8 iscap);
//	
//	    /************************************************************************
//	     * @function: BcdCharToValue
//	     * @描述: 数值转换
//	     * 
//	     * @参数: 
//	     * @param: ch 需要转换的字符
//	     * 
//	     * @返回: 
//	     * @return: uint8  Ch如果是'0'-'9'中的成员那么输出其转后的值,否则输出0xFF表示无法转换
//	     * @说明: 比如ch = '9',那么转换后是0x09, 如果ch ='a',那么将返回0xff表示无法转换
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*BcdCharToValue)(uint8 ch);
//	
//	
//	    /************************************************************************
//	     * @function: BcdStringToNum
//	     * @描述: BCD格式字符串表示为数值
//	     * 
//	     * @参数: 
//	     * @param: ch 需要转换的字符串
//	     * @param: length 需要转换的字符串的长度(<=9)
//	     * 
//	     * @返回: 
//	     * @return: uint32  0－999999999转换后的结果,>999999999无法转换
//	     * @说明: 比如ch[0] = '2',ch[1] = '1', ch[2] = '3',
//	     *        length = 3那么转换后的结果为213; 如果ch[0] = 'f',
//	     *        那么将返回1000000000
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*BcdStringToNum)(uint8* ch, uint8 length);
//	
//	    /************************************************************************
//	     * @function: NumToBcdString
//	     * @描述: 数值表示为BCD格式字符串
//	     * 
//	     * @参数: 
//	     * @param: ch 转换后的字符串
//	     * @param: num 需要转换的数
//	     * @param: format 表示是否需要格式化转换 0:不需要
//	     *                  1-9转换后的字符长度,如果不足,前面的字节用0代替
//	     * 
//	     * @返回: 
//	     * @return: uint8  1-9转换后的有效长度.
//	     * @说明: byte = 56,format = 0,那么转换后的结果为 ch[0] = '5', ch[1] = '6', 返回值为2
//	     *        byte = 56, format = 8, 那么转换后的结果为ch[0]~ch[5] = '0',
//	     *        ch[6] = '5', ch[7] = '6', 返回值为2
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*NumToBcdString)(uint8* ch, uint32 num, uint8 format);
//	
//	    /************************************************************************
//	     * @function: HexStringToNum
//	     * @描述: HEX格式字符串表示为数值
//	     * 
//	     * @参数: 
//	     * @param: ch 需要转换的字符串
//	     * @param: byte 转换后的字节数组
//	     * @param: length 一共要转换的字符数（偶数才是合法的）
//	     * 
//	     * @返回: 
//	     * @return: uint8  true 转换成功
//	     *	              false 转换失败
//	     * @说明: 比如 ch = "567F",那么转换之后的结果为byte[0] = 0x56,byte[1] = 0x7F
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*HexStringToNum)(uint8* ch, uint8* byte, uint16 length);
//	
//	    /************************************************************************
//	     * @function: NumToHexString
//	     * @描述: 数值表示为BCD格式字符串
//	     * 
//	     * @参数: 
//	     * @param: ch 转换后的字符串
//	     * @param: byte 需要转换的字节数组
//	     * @param: length 一共要转换的字节数
//	     * 
//	     * @返回: 
//	     * @return: uint8 0成功.其他失败
//	     * @说明: 刚好是HexStringToNum的逆过程
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*NumToHexString)(uint8* ch, uint8* byte, uint16 length);
//	
//	    /************************************************************************
//	     * @function: ByteArrayBcdToHexString
//	     * @描述: 将BCD字节串转成ascii
//	     * 
//	     * @参数: 
//	     * @param: bcdary 需要转换的数据
//	     * @param: ascii 转换好的字符串
//	     * @param: len 需要转换的数据的长度
//	     * @param: big 是否big-endian输出
//	     * @返回: 
//	     * @说明: 如 hexary[0] = 0x01, hexary[1] = 0x0A, len = 2, 
//	     *       若big为真,输出ascii[0]-[3]为 '0' '1' '0' 'A' 
//	     *       若big为假,输出ascii[0]-[3]为 '0' 'A' '0' '1'
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*ByteArrayBcdToHexString)(uint8* bcdary, uint8* ascii, uint32 len, uint8 big);
//	
//	    /************************************************************************
//	     * @function: AbsVal
//	     * @描述: 
//	     * 
//	     * @参数: 
//	     * @param: value 原数据
//	     * 
//	     * @返回: 
//	     * @return: uint32  绝对值
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*AbsVal)(int32 value);
//	
//	    /************************************************************************
//	     * @function: AbsVal64
//	     * @描述: 
//	     * 
//	     * @参数: 
//	     * @param: value 原数据
//	     * 
//	     * @返回: 
//	     * @return: uint32  绝对值
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint64 (*AbsVal64)(int64 value);
//	
//	    /************************************************************************
//	     * @function: DoSum
//	     * @描述: 累加和计算
//	     * 
//	     * @参数: 
//	     * @param: buff 需要计算累加和的字符数组
//	     * @param: length 需要计算累加和的字节数
//	     * 
//	     * @返回: 
//	     * @return: uint16  计算后的累加和
//	     * @说明: 计算后的累加和，大于65536将自动溢出
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*DoSum)(uint8* buff, uint16 length);
//	
//	    /************************************************************************
//	     * @function: DoBitSum
//	     * @描述: 位加和计算
//	     * 
//	     * @参数: 
//	     * @param: buff 需要计算位加和(异或)的字符数组
//	     * @param: length 需要计算位加和的字节数
//	     * 
//	     * @返回: 
//	     * @return: uint8  计算后的位加和
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*DoBitSum)(uint8* buff, uint16 length);
//	
//	    /************************************************************************
//	     * @function: DoCrc16
//	     * @描述: CRC16校验和计算
//	     * 
//	     * @参数: 
//	     * @param: buff 需要计算CRC16的字节数组
//	     * @param: length 需要计算CRC16的字节数
//	     * @param: init 计算CRC16的初始值
//	     * 
//	     * @返回: 
//	     * @return: uint16  计算后的CRC值
//	     * @说明: 多项式 X16 + X12 + X5 + X1
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*DoCrc16)(uint8* buff, uint16 length, uint16 init);
//	    
//	    /************************************************************************
//	     * @function: DoCrcDlms
//	     * @描述: DLMS帧的crc计算函数
//	     * 
//	     * @参数: 
//	     * @param: buffer 
//	     * @param: length 
//	     * @param: init 
//	     * 
//	     * @返回: 
//	     * @return: uint16  
//	     * @说明: 
//	     * @作者: yzy (2014/5/26)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*DoCrcDlms)(uint8* buffer, uint16 length, uint16 init);
//	
//	    /************************************************************************
//	     * @function: CalcWeek
//	     * @描述: 根据时间计算星期(以07年1月1日为基准,07年1月1日星期一)
//	     * 
//	     * @参数: 
//	     * @param: date 日月年,HEX 
//	     * 
//	     * @返回: 
//	     * @return: uint8  星期(0-6,星期天为0).
//	     *                  0xFF表示输入格式有误
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*CalcWeek)(uint8* date);
//	
//	    /************************************************************************
//	     * @function: CalcDayHex
//	     * @描述: 计算指定时刻的总天数(以00年1月1日为基准)
//	     * 
//	     * @参数: 
//	     * @param: year 年
//	     * @param: month 月
//	     * @param: day 日
//	     * 
//	     * @返回: 
//	     * @return: uint16  将所有的数据转换成天之后的值
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*CalcDayHex)(uint8 year, uint8 month, uint8 day);
//	
//	    /************************************************************************
//	     * @function: CalcHourHex
//	     * @描述: 计算指定时刻的总小时数
//	     * 
//	     * @参数: 
//	     * @param: year 年,hex
//	     * @param: month 月
//	     * @param: day 日
//	     * @param: hour 时
//	     * 
//	     * @返回: 
//	     * @return: uint32  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*CalcHourHex)(uint8 year, uint8 month, uint8 day, uint8 hour);
//	
//	    /************************************************************************
//	     * @function: CalcMinuteHex
//	     * @描述: 计算指定时刻的总分种数
//	     * 
//	     * @参数: 
//	     * @param: year 年,hex
//	     * @param: month 月
//	     * @param: day 日
//	     * @param: hour 时
//	     * @param: mins 分
//	     * 
//	     * @返回: 
//	     * @return: uint32  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: yzy
//	     * 更改函数原型
//	     ************************************************************************/
//	    uint32 (*CalcMinuteHex)(uint8 year, uint8 month, uint8 day, uint8 hour, uint8 mins);
//	
//	    /************************************************************************
//	     * @function: CalcMins
//	     * @描述: 计算指定时刻的总分种数
//	     * 
//	     * @参数: 
//	     * @param: time B0-B4:分时日月年
//	     * @param: isbcd 1bcd,0hex
//	     * 
//	     * @返回: 
//	     * @return: uint32  将所有的数据转换成分之后的值
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*CalcMins)(uint8* time, uint8 isbcd);
//	
//	    /************************************************************************
//	     * @function: CalcSecs
//	     * @描述: 计算指定时刻的总秒数
//	     * 
//	     * @参数: 
//	     * @param: time B0-B5:秒分时日月年
//	     * @param: isbcd 1bcd,0hex
//	     * 
//	     * @返回: 
//	     * @return: uint32  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*CalcSecs)(uint8* time, uint8 isbcd);
//	
//	    /************************************************************************
//	     * @function: CalcTimeFromMins
//	     * @描述: CalcMins()反函数
//	     * 
//	     * @参数: 
//	     * @param: out B0-B4:mmHHDDMMYY,hex
//	     * @param: mins 总分钟数 
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*CalcTimeFromMins)(uint8* out, uint32 mins);
//	
//	    /************************************************************************
//	     * @function: CalcTimeFromSecs
//	     * @描述: CalcSecs()反函数
//	     * 
//	     * @参数: 
//	     * @param: out B0-B5:ssmmHHDDMMYY,hex
//	     * @param: secs 分钟数 
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*CalcTimeFromSecs)(uint8* out, uint32 secs);
//	
//	    /************************************************************************
//	     * @function: U16_little_big_endian
//	     * @描述: 从little_endian的形式转换到big_endian的形式
//	     * 
//	     * @参数: 
//	     * @param: little little_endian的表现形式
//	     * 
//	     * @返回: 
//	     * @return: uint16 big_endian的表现形式 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*U16_little_big_endian)(uint16 little);
//	
//	    /************************************************************************
//	     * @function: U32_little_big_endian
//	     * @描述: 从little_endian的形式转换到big_endian的形式
//	     * 
//	     * @参数: 
//	     * @param: little little_endian的表现形式
//	     * 
//	     * @返回: 
//	     * @return: uint32  big_endian的表现形式
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*U32_little_big_endian)(uint32 little);
//	
//	    /************************************************************************
//	     * @function: CheckBufferCRC
//	     * @描述: 验证缓存中的CRC
//	     * 
//	     * @参数: 
//	     * @param: buffer 缓存
//	     * @param: size 缓存的大小
//	     * @param: end true CRC值在缓存结尾,false CRC值在缓存开头
//	     * 
//	     * @返回: 
//	     * @return: uint8  true 验证成功
//	     *                false 验证失败
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*CheckBufferCRC)(uint8* buffer, uint16 size, uint8 end);
//	
//	    /************************************************************************
//	     * @function: BuildBufferCRC
//	     * @描述: 建立缓存中的CRC
//	     * 
//	     * @参数: 
//	     * @param: buffer 缓存
//	     * @param: size 缓存的大小
//	     * @param: end true CRC值在缓存结尾,false CRC值在缓存开头
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*BuildBufferCRC)(uint8* buffer, uint16 size, uint8 end);
//	
//	    /************************************************************************
//	     * @function: sqrt_16
//	     * @描述: 开根号处理
//	     * 
//	     * @参数: 
//	     * @param: M 长整型
//	     * 
//	     * @返回: 
//	     * @return: uint16 整型 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*sqrt_16)(uint32 M);
//	
//	    /************************************************************************
//	     * @function: MidWaySearch
//	     * @描述: 中值法搜索想要的内容,Key为uint16类型
//	     * 
//	     * @参数: 
//	     * @param: pdata 需要搜索的内容.为目标结构体的数组的起始位置.结构体第一个元素必须是序号,uint16类型
//	     * @param: size 结构体总数
//	     * @param: len 每个结构体的长度
//	     * @param: id 目标序号
//	     * 
//	     * @返回: 
//	     * @return: uint16  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*MidWaySearch)(uint8* pdata, uint16 size, uint16 len, uint16 id);
//	
//	    /************************************************************************
//	     * @function: LongMidWaySearch
//	     * @描述: 中值法搜索想要的内容,Key为长整形
//	     * 
//	     * @参数: 
//	     * @param: pdata 需要搜索的内容.为目标结构体的数组的起始位置.结构体第一个元素必须是序号,uint32类型
//	     * @param: size 结构体总数
//	     * @param: len 每个结构体的长度
//	     * @param: id 目标序号
//	     * 
//	     * @返回: 
//	     * @return: uint16  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*LongMidWaySearch)(uint8* pdata, uint16 size, uint16 len, uint32 id);
//	
//	    /************************************************************************
//	     * @function: ADVMidWaySearch
//	     * @描述: 加强的中值法搜索想要的内容.即在中值法查找基础上,增加同类项支持
//	     * 
//	     * @参数: 
//	     * @param: pdata 需要搜索的内容.为目标结构体的数组的起始位置.结构体第一个元素必须是序号,uint32类型
//	     * @param: size 结构体总数
//	     * @param: len 每个结构体的长度
//	     * @param: id 目标序号
//	     * 
//	     * @返回: 
//	     * @return: uint16  
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*ADVMidWaySearch)(uint8* pdata, uint16 size, uint16 len, uint16 id);
//	
//	    /************************************************************************
//	     * @function: CopyBufferToStr
//	     * @描述: 将缓存里面的内容拷贝到结构体中
//	     * 
//	     * @参数: 
//	     * @param: sb 结构体描述信息
//	     * @param: buffer 缓存
//	     * @param: num 数量
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*CopyBufferToStr)(const StrBuffer* sb, uint8* buffer, uint16 num);
//	
//	    /************************************************************************
//	     * @function: CopyStrToBuffer
//	     * @描述: 将结构体里面的内容拷贝到缓存里面
//	     * 
//	     * @参数: 
//	     * @param: sb 结构体描述信息
//	     * @param: buffer 缓存
//	     * @param: num 数量
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*CopyStrToBuffer)(const StrBuffer* sb, uint8* buffer, uint16 num);
//	
//	    /************************************************************************
//	     * @function: CopyBufferToStrOffset
//	     * @描述: 将缓存里面的内容拷贝到结构体中
//	     * 
//	     * @参数: 
//	     * @param: sb 结构体描述信息
//	     * @param: str 结构体地址
//	     * @param: buffer 缓存
//	     * @param: num 数量
//	     * 
//	     * @返回: 
//	     * @return: uint16  操作的缓冲区的长度
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*CopyBufferToStrOffset)(const StrBufOffset* sb, void* str, uint8* buffer, uint16 num);
//	
//	    /************************************************************************
//	     * @function: CopyStrToBufferOffset
//	     * @描述: 将结构体里面的内容拷贝到缓存里面
//	     * 
//	     * @参数: 
//	     * @param: sb 结构体描述信息
//	     * @param: str 结构体地址
//	     * @param: buffer 缓存
//	     * @param: num 数量
//	     * 
//	     * @返回: 
//	     * @return: uint16  操作的缓冲区长度
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*CopyStrToBufferOffset)(const StrBufOffset* sb, void* str, uint8* buffer, uint16 num);
//	
//	    /************************************************************************
//	     * @function: FloatToFixPoint
//	     * @描述: 32位浮点数转换成定点数
//	     * 
//	     * @参数: 
//	     * @param: f 浮点数开始的缓存
//	     * @param: nf 转换好的小数位数 
//	     * 
//	     * @返回: 
//	     * @return: uint32  操作的缓冲区长度
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint32 (*FloatToFixPoint)(uint8* f, uint8 nf);
//	    
//	    /************************************************************************
//	     * @function: CalcUartRecvTimeOut
//	     * @描述: 根据串口波特率计算串口接收超时的延时时间
//	     * 
//	     * @参数: 
//	     * @param: baudrate 波特率
//	     * @param: 
//	     * 
//	     * @返回: 
//	     * @return: uint16 超时时间,单位ms
//	     * @说明: 
//	     * @作者: yzy (2013/6/6)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*CalcUartRecvTimeOut)(uint32 baudrate);
//	}_F_CALC;
//	
//	EXT_APIS const _F_CALC gs_Calclib;
//	#endif

//	

typedef struct
{
//	    TResult (*Message_AyncSend)(TESMsg*, uint8);
    int    (*Message_Send)(void *, void *, size_t);
//	    TResult (*Message_SyncSend)(TESMsg*, uint8);
//	    uint8   (*Message_Wait)(TESMsg**);
//	    uint8   (*Message_Get)(TESMsg**);
//	    void    (*Sched)(void);
//	    TResult (*SEM_Create)(uint8, TESRes*);
//	    TResult (*SEM_Get)(uint16, TESRes*);
//	    TResult (*SEM_Release)(TESRes*);
//	    TResult (*SEM_Wait)(TESRes*, uint16);
//	    TResult (*SEM_Accept)(TESRes*);
//	    TResult (*TK_Create)(TESTcbVar*, const TESTcbConst*);
//	    TResult (*TK_Resume)(uint8);
    void    (*TK_Sleep)(int);
//	    TResult (*TK_Suspend)(uint8);
}_F_OS;  
EXT_APIS const _F_OS gs_OS;
//	
//	
//	typedef struct
//	{
//	    /***********************************************************
//	     * @function_name: SYS_Timer_Create
//	     * @function_file: SYS_timer.c
//	     * @描述:创建timer，不支持删除timer
//	     * 
//	     * 
//	     * @参数: 
//	     * @param:tickfunc  timer到期后调用的函数(该函数返回值__true重复触发,false单次触发)
//	     * @param:tickpara  传入上面的函数的参数
//	     * @param:timeout  定时时间.yzy 单位1个systick即10ms.
//	     * @param:timerid  timerid 创建的时候不要重复,否则无法创建
//	     * @param:stoped  创建后是否启动 true停止 false 启动
//	     * 
//	     * @返回: 
//	     * @return: TResult 
//	     * @作者:
//	     *---------------------------------------------------------
//	     * @修改人: houpm (2010/2/11)
//	     **********************************************************/
//	    TResult (*Timer_Create)(Boolean (*tickfunc)(void*), void* tickpara, uint16 timeout, uint8 timerid, uint8 stoped);
//	    
//	    /***********************************************************
//	     * @function_name: SYS_Timer_Start
//	     * @function_file: SYS_timer.c
//	     * @描述:启动timer
//	     * 
//	     * 
//	     * @参数: 
//	     * @param:timerid  
//	     * 
//	     * @返回: 
//	     * @return: TResult 
//	     * @作者:
//	     *---------------------------------------------------------
//	     * @修改人: houpm (2010/2/11)
//	     **********************************************************/
//	    TResult (*Timer_Start)(uint8 timerid);
//	    
//	    /***********************************************************
//	     * @function_name: SYS_Timer_StartOne
//	     * @function_file: SYS_timer.c
//	     * @描述:启动timer,每次启动时可设置该定时器的超时时间.yzy 单位1个systick即10ms.
//	     * 
//	     * 
//	     * @参数: 
//	     * @param: timerid  
//	     * @param: count 延时时间,单位10ms  
//	     * 
//	     * @返回: 
//	     * @return: TResult 
//	     * @作者:
//	     *---------------------------------------------------------
//	     * @修改人: yzy (2010/11/23)
//	     **********************************************************/
//	    TResult (*Timer_StartOne)(uint8 timerid, uint16 count);
//	    
//	    /***********************************************************
//	     * @function_name: SYS_Timer_Stop
//	     * @function_file: SYS_timer.c
//	     * @描述:启动timer
//	     * 
//	     * 
//	     * @参数: 
//	     * @param: timerid  
//	     * 
//	     * @返回: 
//	     * @return: TResult 
//	     * @作者:
//	     *---------------------------------------------------------
//	     * @修改人: houpm (2010/2/11)
//	     **********************************************************/
//	    TResult (*Timer_Stop)(uint8 timerid);
//	
//	}_F_TIMER;
//	EXT_APIS const _F_TIMER gs_Timer;
//	
//	
//	typedef struct
//	{
//	    void* (*GetMEM)(uint32);
//	}_F_MEM;
//	EXT_APIS const _F_MEM gs_Mem;










#if (SYS_GPI_EN > 0) || (SYS_GPO_EN > 0)
typedef struct
{
    /*******************************************************************************
     * @function_name:  LB_Init
     * @描述: LED/Beep初始化
     * 
     * @参数: 
     * @返回: 
     * @作者: yzy (2010-03-11)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    void (*LB_Init)(void);

    /************************************************************************
     * @function: SYS_LED_BlinkSet
     * @描述: LED/Beep点亮熄灭接口函数
     * 
     * @参数: 
     * @param: led 操作的LED/Beep灯序号
     * @param: type 0 只亮一下, 1 闪烁, 2 常亮,其他 熄灭
     * @param: interval 闪烁间隔,时间单位100ms(type为1时有效)
     * @param: time 亮的时间 单位1s(0表示永久有效)
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/6/8)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void (*BlinkSet)(LedNo led, uint8 type, uint8 interval, uint8 time);
    
    /************************************************************************
     * @function: BlinkSetAll
     * @描述: LED/Beep统一点亮熄灭接口函数
     * 
     * @参数: 
     * @param: type 0 只亮一下, 1 闪烁, 2 常亮,其他 熄灭
     * @param: interval 闪烁间隔,时间单位100ms(type为1时有效)
     * @param: time 亮的时间 单位1s(0表示永久有效)
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/6/8)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void (*BlinkSetAll)(uint8 type, uint8 interval, uint8 time);
    
	
    /************************************************************************
     * @function: BlinkSet1
     * @描述: LED/Beep点亮熄灭接口函数
     * 
     * @参数: 
     * @param: led 操作的LED/Beep灯序号
     * @param: type 0 只亮一下, 1 闪烁, 2 常亮,其他 熄灭
     * @param: oninterval 点亮间隔,时间单位100ms(type为1时有效)
     * @param: offinterval 熄灭间隔,时间单位100ms(type为1时有效)
     * @param: time 亮的时间 单位1s(0表示永久有效)
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/6/8)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void (*BlinkSet1)(LedNo led, uint8 type, uint8 oninterval, uint8 offinterval, uint8 time);
    
    
    /************************************************************************
     * @function: BlinkSetAll1
     * @描述: LED/Beep统一点亮熄灭接口函数
     * 
     * @参数: 
     * @param: type 0 只亮一下,1 闪烁,2 常亮,其他 熄灭
     * @param: oninterval 闪烁间隔,时间单位100ms(type为1时有效)
     * @param: offinterval 熄灭间隔,时间单位100ms(type为1时有效)
     * @param: time 亮的时间 单位1s(0表示永久有效)
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/6/8)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    void (*BlinkSetAll1)(uint8 type, uint8 oninterval, uint8 offinterval, uint8 time);
    /*******************************************************************************
     * @function_name:  GPI_Init
     * @描述: 
     * 
     * @参数: 
     * @返回: 
     * @作者: yzy (2010-03-10)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    void (*GPI_Init)(void);

    /*******************************************************************************
     * @function_name:  GPI_GetStt
     * @描述: 获取输入口输入状态
     * 
     * 
     * @参数: 
     * @param: type 0:慢速口输入状态
     *              1:快速口输入状态
     * 
     * @返回: 
     * @return:  uint32   
     * @作者: yzy (2018年3月22日)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    uint32 (*GPI_GetStt)(uint8 type);
    
    /*******************************************************************************
     * @function_name:  GPI_Event
     * @function_file:  dev_gpio.c
     * @描述: 获取输入口事件
     * 
     * 
     * @参数: 
     * @param: type事件类型,格式为GPI_T
     * 
     * @返回: 
     * @return:  uint16   
     * @作者: yzy (2018年3月22日)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    uint32 (*GPI_Event)(uint8 type);
    /*******************************************************************************
     * @function_name:  GPI_PinStt
     * @描述: 获取输入口输入状态
     * 
     * 
     * @参数: 
     * @param: type 0:慢速口输入状态 
     *              1:快速口输入状态
     * @param: pin 对照iomap.h的管脚定义
     * @返回:   true 高电平 false 低电平
     * @return:  uint8   
     * @作者: yzy (2018年3月22日)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    uint8 (*GPI_PinStt)(uint8 type, GPIENUM pin);


    /*******************************************************************************
     * @function_name:  SYS_GPO_Init
     * @function_file:  dev_gpio.c
     * @描述: GPO设备初始化
     * 
     * @参数: 
     * @返回: 
     * @作者: yzy (2010-03-11)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    void (*GPO_Init)(void);
    
    /*******************************************************************************
     * @function_name:  SYS_GPO_Out
     * @function_file:  dev_gpio.c
     * @描述: GPO输出
     * 
     * 
     * @参数: 
     * @param: gpo(GPOENUM): 
     * @param: oc(uint8): true 输出高电平, false 输出低电平
     * @返回: 
     * @作者: yzy (2010-03-11)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    void (*GPO_Out)(GPOENUM gpo, uint8 oc);
}_F_GPIO;
EXT_APIS const _F_GPIO gs_GPIO;
#endif







typedef struct
{
    uint8 (*ReadDateTime)(TIME* datetime);
    uint8 (*ReadBCDDateTime)(TIME* datetime);
    uint8 (*WriteDateTime)(TIME* datetime);
    uint8 (*WriteBCDDateTime)(TIME* datetime);
    const TIME* (*GetTime)(void);
}_F_RTC;
EXT_APIS const _F_RTC gs_RealTime;



//	#if SYS_SER_EN >0
//	typedef struct
//	{
//	
//	    /************************************************************************
//	     * @function: SER_Open
//	     * @描述: 串口打开
//	     * 
//	     * @参数: 
//	     * @param: port 
//	     * @param: isAnsyc true:异步,打不开则退出.false:同步,等待直到获取资源
//	     * 
//	     * @返回: 
//	     * @return: uint8  
//	     * @说明: 
//	     * @作者: yzy (2018/5/2)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*open)(uint8 port, uint8 isAnsyc);
//	    
//	    /************************************************************************
//	     * @function: SYS_SER_Close
//	     * @描述: 串口关闭
//	     * 
//	     * @参数: 
//	     * @param: port 
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2018/5/2)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*close)(uint8 port);
//	
//	    /************************************************************************
//	     * @function: SER_Clear
//	     * @描述: 清空串口缓存
//	     * 
//	     * @参数: 
//	     * @param: port 
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*Clear)(uint8 port);
//	     
//	    /************************************************************************
//	     * @function: SYS_SER_Init
//	     * @描述: 串口配置
//	     * 
//	     * @参数: 
//	     * @param: port 
//	     * @param: ss 
//	     * @返回: 
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    void (*Init)(uint8 port, SerialSets* ss); 
//	     
//	    /************************************************************************
//	     * @function: SER_ReadByte
//	     * @描述: 从串口读取一个字节数据
//	     * 
//	     * @参数: 
//	     * @param: port 
//	     * 
//	     * @返回: 
//	     * @return: uint16  
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*ReadByte)(uint8 port); 
//	    
//	    /************************************************************************
//	     * @function: SYS_SER_Read
//	     * @描述: 串口数据读取
//	     * 
//	     * @参数: 
//	     * @param: port 端口
//	     * @param: buffer 输出缓存,__NULL表示丢弃
//	     * @param: length 读取长度
//	     * 
//	     * @返回: 
//	     * @return: uint16  实际读取长度
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*Read)(uint8 port, uint8* buffer, uint16 length);
//	    
//	    /************************************************************************
//	     * @function: SER_Line
//	     * @描述: 串口读取行命令(若未找到行结束符,串口缓存被读空)
//	     * 
//	     * @参数: 
//	     * @param: port 端口号
//	     * @param: buffer 存放数据缓存,__NULL表示丢弃
//	     * @param: length 存放数据缓存的长度
//	     * 
//	     * @返回: 
//	     * @return: uint16  读取的行长度(包括一个结尾符).
//	     *          0表示无数据或未找到行结束符,1表示仅读到结尾符
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*ReadLine)(uint8 port, uint8* buffer, uint16 length);
//	    
//	    /************************************************************************
//	     * @function: SER_LineLen
//	     * @描述: 获取串口当前行长度
//	     * 
//	     * @参数: 
//	     * @param: port 端口号
//	     * 
//	     * @返回: 
//	     * @return: uint16  行长度(包括一个结尾符)
//	     *          0表示无数据或未找到行结束符,1表示仅读到结尾符
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*LineLen)(uint8 port);
//	    
//	    /************************************************************************
//	     * @function: SER_SendData
//	     * @描述: 串口数据发送
//	     * 
//	     * @参数: 
//	     * @param: port 串口号
//	     * @param: buffer 发送数据缓存
//	     * @param: length 发送数据长度
//	     * 
//	     * @返回: 
//	     * @return: uint8  
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*Write)(uint8 port, uint8* buffer, uint16 length);
//	    
//	    /************************************************************************
//	     * @function: SER_ToBeRead
//	     * @描述: 串口可读取数据的长度
//	     * 
//	     * @参数: 
//	     * @param: port 
//	     * 
//	     * @返回: 
//	     * @return: uint16  
//	     * @说明: 
//	     * @作者: yzy (2013/8/28)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint16 (*ToBeRead)(uint8 port);
//	    
//	    /************************************************************************
//	     * @function: SER_PrintValue
//	     * @描述: 发送数据,按照字符串的格式化进行发送
//	     * 
//	     * @参数: 
//	     * @param: port 串口号
//	     * @param: str 发送的描述字符串
//	     * @param: value 发送的数据
//	     * 
//	     * @返回: 
//	     * @return: uint8  成功/失败
//	     * @说明: 
//	     * @作者: yzy (2013/6/10)
//	     *-----------------------------------------------------------------------
//	     * @修改人: 
//	     ************************************************************************/
//	    uint8 (*PrintValue)(uint8 port, string str, uint32 value);
//	
//	}_F_UART;
//	EXT_APIS const _F_UART gs_Uart;
//	#endif



//	typedef struct 
//	{
//	    TDev* (*DEV_Open)(uint16, uint16, Object);
//	    TResult (*DEV_Add)(TDev*);
//	    Boolean (*DEV_Close)(TDev*);
//	}_F_DEV;
//	
//	EXT_APIS const _F_DEV gs_DEVProc;
#include "public.h"
#include "frmcfg.h"
#include "frm.h"

typedef struct 
{
    /************************************************************************
     * @function: PST_CheckFrame
     * @描述: 
     * 
     * @参数: 
     * @param: num 需要判断的帧的类型编号
     * @param: buffer 需要判断有效帧的缓存
     * @param: length 需要判断的帧的长度
     * 
     * @返回: 
     * @return: uint8  PST_ERR_OK
     *      PST_ERR_VAR
     *      PST_ERR_TS
     *      PST_ERR_NE
     * @说明: 
     * @作者: yzy (2013/7/15)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint8 (*CheckFrame)(uint8 num, uint8* buffer, uint16 length);
    
    /************************************************************************
     * @function: PST_Channel
     * @描述: 带前导符扫描接收报文,判断出为何种规约
     * 
     * @参数: 
     * @param: channel 需要判断有效帧的通道编号
     * @param: buffer 需要判断有效帧的缓存
     * @param: length 需要判断的帧的长度
     * @param: protocol 输出,实际规约编号,如果是0xFF就表示不是有效规约(例:PST_FRM_ZY_NO)
     * 
     * @返回: 
     * @return: uint8  
     * @说明: 
     * @作者: yzy (2013/7/15)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint8 (*Channel)(uint8_t channel, uint8* buffer, uint16 length, uint8* protocol);
    
    /************************************************************************
     * @function: PST_DoneFrame
     * @描述: 进行帧头\帧尾\累加和的填写,对于没有数据区长度的帧这里无法完成其打包
     * 
     * @参数: 
     * @param: num 需要打包的帧的类型编号
     * @param: buffer 需要打包成有效帧的缓存
     * 
     * @返回: 
     * @return: uint16  0 打包失败, 其他 打包后数据的长度
     * @说明: 
     * @作者: yzy (2013/7/15)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint16 (*DoneFrame)(uint8 num, uint8* buffer);
    
    /*******************************************************************************
     * @function_name:  FRM_Decode
     * @function_file:  dev_frm.c
     * @描述: 规约解析函数
     * 
     * 
     * @参数: 
     * @param: protocal  规约序号
     * @param: rbuffer  接收缓存
     * @param: sbuffer  发送缓存
     * @param: sbuflen  发送缓存长度
     * @param: frm  规约帧结构体信息指针
     * 
     * @返回: 
     * @return:  uint8   
     * @作者: yzy (2010-02-27)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    uint8 (*Decode)(uint8 protocal, uint8* rbuffer, uint8* sbuffer, uint16 sbuflen, PST_Frame * frm);
    
    /*******************************************************************************
     * @function_name:  FRM_Proc
     * @function_file:  dev_frm.c
     * @描述: 规约处理函数
     * 
     * 
     * @参数: 
     * @param: protocal  规约序号
     * @param: frm  规约帧结构体信息指针
     * 
     * @返回: 
     * @return:  uint8   
     * @作者: yzy (2010-03-03)
     *-----------------------------------------------------------------------------
     * @修改人: 
     * @修改说明: 
     ******************************************************************************/
    uint8 (*Proc)(uint8 protocal, PST_Frame* frm);
    
    /************************************************************************
     * @function: PST_CheckFrame2
     * @描述: 指定类型帧有效性的检查(若存在前导符,则去掉前导符./不去除帧后的无效字符)
     * 
     * @参数: 
     * @param: nfrm 通讯的规约编号.如果nfrm为0xff表示为中继
     * @param: buffer 帧缓存
     * @param: len 帧长度
     * 
     * @返回: 
     * @return: uint16 合格帧的长度(0表示没有合格帧)
     * @说明: 
     * @作者: yzy (2012-5-15)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    uint16 (*CheckFrame2)(uint8 nfrm, uint8* buffer, uint16 len);
    /************************************************************************
     * @function: __PST_CheckFrame
     * @描述: 帧有效性检查,允许一定数量的前导符,并过滤前导符
     * 
     * @参数: 
     * @param: nfrm 通讯的规约编号,如果nfrm 为 0xff表示为中继
     * @param: buffer 收发缓存
     * @param: len 输入为接收数据长度,输出为有效数据长度
     * 
     * @返回: 
     * @return: uint8  
     * @说明: 
     * @作者: yzy (2013/11/3)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    
    uint8 (*CheckFrame3)(uint8 nfrm, uint8* buffer, uint16* len);
}_F_FRM;


EXT_APIS const _F_FRM gs_FRM;



#if SYS_SER_EN >0
typedef struct
{

    /************************************************************************
     * @function: open
     * @描述: 串口打开
     * 
     * @参数: 
     * @param: ch 
     * @param: option TDB_MODE_R:允许读 .TDB_MODE_W:允许写
     * 
     * @返回: 
     * @return: uint8  
     * @说明: 
     * @作者: yzy (2018/5/2)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32 (*open)(uint8 ch, uint8 option);
    
    /************************************************************************
     * @function: close
     * @描述: 串口关闭
     * 
     * @参数: 
     * @param: ch 
     * @返回: 
     * @说明: 
     * @作者: yzy (2018/5/2)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32 (*Close)(uint8 ch);
	
    /************************************************************************
     * @function: Clear
     * @描述: 清空串口缓存
     * 
     * @参数: 
     * @param: ch 
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32 (*Clear)(uint8 ch);
     
    /************************************************************************
     * @function: Init
     * @描述: 串口配置
     * 
     * @参数: 
     * @param: ch 
     * @param: ss 
     * @返回: 
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32 (*Init)(uint8 ch, void * ss); 
     
    /************************************************************************
     * @function: ReadByte
     * @描述: 从串口读取一个字节数据
     * 
     * @参数: 
     * @param: ch 
     * 
     * @返回: 
     * @return: uint16  
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
//	    int16 (*ReadByte)(uint8 ch); 
    
    /************************************************************************
     * @function: Read
     * @描述: 串口数据读取
     * 
     * @参数: 
     * @param: ch 端口
     * @param: buffer 输出缓存,__NULL表示丢弃
     * @param: length 读取长度
     * @param: nTimeout 超时时间
     * 
     * @返回: 
     * @return: int32  实际读取长度
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32 (*Read)(uint8 ch, uint8* buffer, int32 length, int32 timeout);
    
    /************************************************************************
     * @function: ReadLine
     * @描述: 串口读取行命令(若未找到行结束符,串口缓存被读空)
     * 
     * @参数: 
     * @param: ch 端口号
     * @param: buffer 存放数据缓存,__NULL表示丢弃
     * @param: length 存放数据缓存的长度
     * 
     * @返回: 
     * @return: uint16  读取的行长度(包括一个结尾符).
     *          0表示无数据或未找到行结束符,1表示仅读到结尾符
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
//	    int16 (*ReadLine)(uint8 ch, uint8* buffer, uint16 length);
    
    /************************************************************************
     * @function: LineLen
     * @描述: 获取串口当前行长度
     * 
     * @参数: 
     * @param: ch 端口号
     * 
     * @返回: 
     * @return: uint16  行长度(包括一个结尾符)
     *          0表示无数据或未找到行结束符,1表示仅读到结尾符
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
//	    int16 (*LineLen)(uint8 ch);
    
    /************************************************************************
     * @function: Write
     * @描述: 串口数据发送
     * 
     * @参数: 
     * @param: ch 串口号
     * @param: buffer 发送数据缓存
     * @param: length 发送数据长度
     * @param: length 存放数据缓存的长度
     * @返回: 
     * @return: uint8  
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32_t (*Write)(uint8 ch, uint8* buffer, int32 length, int32 timeout);
    
    /************************************************************************
     * @function: ToBeRead
     * @描述: 串口可读取数据的长度
     * 
     * @参数: 
     * @param: ch 
     * 
     * @返回: 
     * @return: uint16  
     * @说明: 
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
    int32_t (*ToBeRead)(uint8 ch);
    
    /************************************************************************
     * @function: PrintValue
     * @描述: 发送数据,按照字符串的格式化进行发送
     * 
     * @参数: 
     * @param: ch 串口号
     * @param: buffer 缓存  
     * @param: buflen 缓存长度     
     * @param: timeout 发送延时
     * @param: str 发送的描述字符串
     * @param: ... 发送的数据
     * 
     * @返回: 
     * @return: uint8  成功/失败
     * @说明: 
     * @作者: yzy (2013/6/10)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
//	    int32 (*PrintValue)(uint8 ch, uint8 * buff, uint16 buflen, int32 timeout, const int8 * str, ...);
    /************************************************************************
     * @function: Peek
     * @描述: 串口接收数据窥探,执行后数据仍然存在于接收缓存内
     * 
     * @参数: 
     * @param: ch 端口
     * @param: buffer 存放窥探数据的缓存
     * @param: start 从第几个数据开始窥探(0-) 
     * @param: length 待窥探数据长度
     * 
     * @返回: 
     * @return: uint16  窥探得到的实际数据长度
     * @说明: SYS_SER_Read()的部分功能
     * @作者: yzy (2013/8/28)
     *-----------------------------------------------------------------------
     * @修改人: 
     ************************************************************************/
//	    int16 (*Peek)(uint8 ch, uint8* buffer, uint16 start, uint16 length);

}_F_UART;
#endif


EXT_APIS const _F_UART gs_Uart;



#endif























