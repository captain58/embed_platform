/****************************************Copyright (c)**************************************************
**                                  ________科技有限公司
**                                          开发部
**
**
**--------------文件信息--------------------------------------------------------------------------------
** 文   件   名: SimpleCalcLib.c
** 创   建   人: yzy
** 最后修改日期: 2006年8月4日
** 描        述: 简单数据处理函数库源文件
** 注        意:
**--------------历史版本信息----------------------------------------------------------------------------
** 创建人: yzy
** 版  本: v1.0
** 日　期: 2006年8月4日
** 描　述: 原始版本
**--------------约定------------------------------------------------------------------------------------
** 修改人:yzy
** 关于数值类型的约定 
**  
** Hex/Value(BcdCharToValue,HexCharToValue)/Num(BcdStringToNum,HexStringToNum等):十六进制
** Bcd:压缩型BCD.       范围0-0x99,高4位和低4位均为0-9.         比如0x34表示十进制34
** 
**  
** 关于字符类型的约定 
** BcdChar:BCD字符      范围'0'-'9'.
** HexChar:HEX字符      范围'0'-'9','a'-f','A'-'F'.
** BcdString:BCD字符串  由若干个BcdChar组成.
** HexString:HEX字符串  由若干个HexChar组成.
**--------------约定------------------------------------------------------------------------------------ 
** 修改人:yzy
** 修改时间:2013年6月6日 
** BcdStringToByte因与BcdStringToNum功能重复,删除
** ByteToBcdString因与NumToBcdString功能重复,删除
** ByteArrayBcdToAscii因命名不够准确,改名为ByteArrayBcdToHexString

** GetFirstSetBit因与STR_GetFirstSetBit功能重复,删除

** CalcDay,CalcDays因与CalcDayHex功能重复,删除
** CalcHours因与CalcHour功能重复,删除
** CalcMinute因与CalcMins功能重复,删除
** CalcSecond因与CalcSecs功能重复,删除

** CalcMinuteHex更改原型
** GetNumFromString用途不具有普遍性,删除
********************************************************************************************************/
#define EXT_SIMPLECALCLIB
 
#include <stdint.h>

#include "aos/bdef.h"
#include "cdef.h"

#include "libs.h"





/********************************************************************************************************
**简单运算库文件的常量区,一些常用的运算的常量可以在这里找到
**第一部分是位操作运算常用的表格
**第二部分是时间操作运算常用的数据
*********************************************************************************************************/

//十进制乘法运算的倍数
const uint32 guls_Do10Value[10] = 
{
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000,
    1000000000,
};
/*******************************************************************************************************/

                                        //8位掩码
const uint8 Bit_Mask8[9] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF};
                                        //16位掩码
const uint16 Bit_Mask16[17] = {  0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
                                0x001F, 0x003F, 0x007F, 0x00FF,
                                0x01FF, 0x03FF, 0x07FF, 0x0FFF,
                                0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF,};
                                        //32位掩码
const uint32 Bit_Mask32[33] = { 0x00000000, 0x00000001, 0x00000003, 0x00000007, 
                                0x0000000F, 0x0000001F, 0x0000003F, 0x0000007F, 
                                0x000000FF, 0x000001FF, 0x000003FF, 0x000007FF, 
                                0x00000FFF, 0x00001FFF, 0x00003FFF, 0x00007FFF, 
                                0x0000FFFF, 0x0001FFFF, 0x0003FFFF, 0x0007FFFF,
                                0x000FFFFF, 0x001FFFFF, 0x003FFFFF, 0x007FFFFF,
                                0x00FFFFFF, 0x01FFFFFF, 0x03FFFFFF, 0x07FFFFFF,
                                0x0FFFFFFF, 0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF,
                                0xFFFFFFFF
                            };
                                        //8位位码
const uint8 Bit_Map8[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
                                        //16位位码
const uint16 Bit_Map16[16] = {   0x0001, 0x0002, 0x0004, 0x0008,
                                0x0010, 0x0020, 0x0040, 0x0080,
                                0x0100, 0x0200, 0x0400, 0x0800,
                                0x1000, 0x2000, 0x4000, 0x8000,
                            };

                                        //32位位码
const uint32 Bit_Map32[32] = {  0x00000001, 0x00000002, 0x00000004, 0x00000008,
                                0x00000010, 0x00000020, 0x00000040, 0x00000080,
                                0x00000100, 0x00000200, 0x00000400, 0x00000800,
                                0x00001000, 0x00002000, 0x00004000, 0x00008000,
                                0x00010000, 0x00020000, 0x00040000, 0x00080000,
                                0x00100000, 0x00200000, 0x00400000, 0x00800000,
                                0x01000000, 0x02000000, 0x04000000, 0x08000000,
                                0x10000000, 0x20000000, 0x40000000, 0x80000000,
                            };
                                        //字节的最低位索引
const uint8 Bit_Maps[256] =
{
    0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xF0 to 0xFF                             */
};



/*******************************************************************************************************/


const uint16 gui_DayMinCount = 1440; //每天的分钟数
const uint16 gui_HourSecCount = 3600;//每小时的秒数
const uint16 gui_QuartYearDay = 1461;//4年的天的数量
const uint32 gul_DaySecCount = 86400;//1天中秒的数量
                                        //4年中每年开始的数量
const uint16 gui_FourYearDayLoop[4] = {0, 366, 731, 1096};

                                        //平年的月份数
const uint8 guc_LYearMonth[12]= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
                                        //闰年的月份数
const uint8 guc_BYearMonth[12]= {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
                                        //每个月开始的天数
const uint16 gui_MonthBeginDay[12] = {0, 31, 59, 90,120, 151, 181, 212, 243, 273, 304, 334};









/************************************************************************
 * @function: MoveBuffer
 * @描述: 移动缓存值
 * 
 * @参数: 
 * @param: sbuff 源地址
 * @param: tbuff 目标地址
 * @param: length 移动的字节数
 * 
 * @返回: 
 * @return: void  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void MoveBuffer(uint8* sbuff, uint8* tbuff, uint32 length)
{
                                            //先判断是否有正向移动重叠区域
    if((sbuff < tbuff) && (sbuff + length > tbuff))
    {                                       //有就从反向移动
        while(length != 0)                  //根据长度进行移动
        {
            length --;
            tbuff[length] = sbuff[length];  //移动
        }
    }
    else                                    //其它情况进行正向移动
    {
        while(length != 0)
        {
            length --;
            *tbuff++ = *sbuff++;            //移动
        }
    }
}



/************************************************************************
 * @function: InvBuffer
 * @描述: 字节翻转
 * 
 * @参数: 
 * @param: buff 要字节翻转的缓存
 * @param: length 待翻转的字节数
 * 
 * @返回: 
 * @return: void  
 * @说明: 将一个缓存中的字节的顺序进行反转.
 *         比如buff[0] = 0x12, buff[1] = 0x34, buff[2] = 0x56,
 *         buff[3] = 0x78,那么反转后的结果为buff[0] = 0x78,
 *         buff[1] = 0x56, buff[2] = 0x34, buff[3] = 0x12
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void InvBuffer(uint8* buff, uint32 length)
{
    uint8 uc_temp;
    uint32 ui_len;
                                            //交换的长度应该是所有数据的一半
    for(ui_len = 0; ui_len < (length >> 1); ui_len ++)
    {
        uc_temp = buff[ui_len];             //暂存
                                            //赋值
        buff[ui_len] = buff[length - ui_len - 1];
        buff[length - ui_len - 1] = uc_temp;//完成一次交换
    }
}


/************************************************************************
 * @function: CmpBuffer
 * @描述: 比较缓存是否一致
 * 
 * @参数: 
 * @param: buff1 比较的缓存1
 * @param: buff2 比较的缓存2
 * @param: length 比较的长度
 * 
 * @返回: 
 * @return: uint8 
 *      0: 两个缓存的内容一样
 *      1: 两个缓存的内容不一样,buff1 > buff2
 *      2: 两个缓存的内容不一样,buff1 < buff2
 * @说明: 比较两个缓存里面的内容.从每个缓存的第一个字节开始比较,
 *        直到不一样之后退出,不一样的那两个字节的大小代表了两个缓存的大小.
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 CmpBuffer(uint8* buff1, uint8* buff2, uint32 length)
{
    while(length > 0)                       //循环,逐个字节的进行对比
    {
        length --;                          //长度递减

        if(*buff1 !=  *buff2)   //比较
        {                                   //返回比较好的结果
            if(*buff1 > *buff2)
            {
                return 1;
            }
            else
            {
                return 2;
            }
        }
        buff1++; 
        buff2++;
    }
    return 0;
}



/************************************************************************
 * @function: ClearBuffer
 * @描述: 清零缓存
 * 
 * @参数: 
 * @param: buff 要清零的缓存
 * @param: length 要清零的字节数
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void ClearBuffer(uint8* buff, uint32 length)
{
    uint32 i;

    for(i = 0; i < length; i++)
    {
        buff[i] = 0;                    //每个字节清零
    }

}



/************************************************************************
 * @function: memset
 * @描述: 置数缓存
 * 
 * @参数: 
 * @param: buffer 要置数的缓存
 * @param: val 要置数的值
 * @param: length 要置数的字节数
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
//	void memset(void* buffer, uint8 val, uint32 length)
//	{
//	    uint32 i;
//	    uint8* buf = (uint8*)buffer;
//	    for(i = 0; i < length; i++)
//	    {
//	        buf[i] = val;
//	    }
//	}
//	
//	
//	/************************************************************************
//	 * @function: strlen
//	 * @描述: 计算字符串的长度
//	 * 
//	 * @参数: 
//	 * @param: str 字符串(不超过512字节)
//	 * 
//	 * @返回: 
//	 * @return: uint16  字符串的长度
//	 * @说明: 
//	 * @作者: yzy (2013/6/6)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	uint16 strlen(string str)
//	{
//	    uint16 i = 0;
//	    for(i = 0; i < 512; i++)
//	    {
//	        if(str[i] == 0)
//	        {
//	            break;
//	        }
//	    }
//	    return i;
//	}
//	
//	
//	
//	/************************************************************************
//	 * @function: memcpy
//	 * @描述: 拷贝缓存
//	 * 
//	 * @参数: 
//	 * @param: tb 源地址
//	 * @param: sb 目标地址
//	 * @param: length 移动的字节数
//	 * @返回: 
//	 * @说明: 功能同 MoveBuffer()
//	 * @作者: yzy (2013/6/6)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	void memcpy(void* tb, void* sb, uint32 length)
//	{
//	    uint8* tbuff = tb;
//	    uint8* sbuff = sb;
//	                                            //先判断是否有正向移动重叠区域
//	    if((sbuff < tbuff) && (sbuff + length > tbuff))
//	    {                                       //有就从反向移动
//	        while(length != 0)                  //根据长度进行移动
//	        {
//	            length --;
//	            tbuff[length] = sbuff[length];  //移动
//	        }
//	    }
//	    else                                    //其它情况进行正向移动
//	    {
//	        while(length != 0)
//	        {
//	            length --;
//	            *tbuff++ = *sbuff++;            //移动
//	        }
//	    }
//	}
//	
//	
//	/************************************************************************
//	 * @function: strcpy
//	 * @描述: 拷贝字符串
//	 * 
//	 * @参数: 
//	 * @param: str1 目标字符串
//	 * @param: str2 源字符串
//	 * 
//	 * @返回: 
//	 * @return: uint16 字符串的长度
//	 * @说明: 
//	 * @作者: yzy (2013/6/6)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	uint16 strcpy(string str1, string str2)
//	{
//	    memcpy((void*)str1, (void*)str2, strlen(str2) + 1);
//	    return strlen(str2);
//	}
//	
//	/************************************************************************
//	 * @function: strstr
//	 * @描述: 查找字符串
//	 * 
//	 * @参数: 
//	 * @param: str1 被查找字符串
//	 * @param: str2 要查找字符串
//	 * 
//	 * @返回: 
//	 * @return: 若str2若是str1的子串，则返回str1在str2首位置的地址，如果不是，则返回NULL
//	 * @说明: 
//	 * @作者: yzy (2015/3/16)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	
//	char * strstr(const char * str1, const char * str2)
//	{
//	    int len2 = 0;
//	    if(NULL == str1 || NULL == str2) 
//	    {
//	        return NULL;
//	    }
//	    if(!(len2 = strlen((string)str2)))
//	    {
//	        return (char *)str1;
//	    }
//	
//	    for(;*str1;str1++)
//	    {
//	        if((*str1 == *str2) && (0 == CmpBuffer((uint8 *)str1,(uint8 *)str2,len2)))
//	        {
//	            return (char *)str1;
//	        }
//	    }
//	    return NULL;
//	}
//	
//	/************************************************************************
//	 * @function: strchar
//	 * @描述: 查找字符串s中首次出现c的位置
//	 * 
//	 * @参数: 
//	 * @param: s 被查找字符串
//	 * @param: c 要查找字符
//	 * 
//	 * @返回: 
//	 * @return: 返回首次出现c的位置的指针，如果s中不存在c则返回NULL
//	 * @说明: 
//	 * @作者: yzy (2015/3/16)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	char * strchar(const char * s, char c)
//	{
//	    while((*s != '\0') && (*s != c))
//	    {
//	        ++s;
//	    }
//	    return (*s == c) ? (char *)s : NULL;
//	}
//	/************************************************************************
//	 * @function: strcat
//	 * @描述: 把src所指字符串添加到dest结尾处(覆盖dest结尾处的'\0')并添加'\0'。
//	 * 
//	 * @参数: 
//	  * @param: strDest 目标字符串
//	 * @param: strSrc   源字符串
//	 * 
//	 * @返回: 
//	 * @return: 返回dest的指针。
//	 * @说明: 
//	 * @作者: yzy (2015/3/16)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	char * strcat(char * strDest,const char * strSrc)
//	{
//	
//	    char * address = strDest;
//	    if((strDest != NULL) && (strSrc != NULL))
//	    {
//	        return address;
//	    }//对源地址和目的地址加非0断言
//	    while( *strDest !='\0')
//	    {
//	    //若使用while(*strDest++)，则会出错，因为循环结束后strDest还会执行一次++,
//	    //那么strDest将指向'\0'的下一个位置。/所以要在循环体内++；因为要是*strDest最后指
//	    //向该字符串的结束标志’\0’。
//	        strDest++;
//	    }
//	     
//	    while(*strDest++ = *strSrc++)
//	    {
//	        ;//该循环条件内可以用++，
//	    }
//	    return address;//为了实现链式操作，将目的地址返回
//	}
//	/************************************************************************
//	 * @function: strrchr
//	 * @描述:查找一个字符c在另一个字符串str中末次出现的位置
//	 * 
//	 * @参数: 
//	 * @param: s 被查找字符串
//	 * @param: c 要查找字符
//	 * 
//	 * @返回: 
//	 * @return:  查找成功就返回字符串，失败则返回NULL
//	 * @说明: 
//	 * @作者: yzy (2015/3/16)
//	 *-----------------------------------------------------------------------
//	 * @修改人: 
//	 ************************************************************************/
//	char * strrchr (const char *s, char c)
//	{
//	    const char *found = NULL, *p = NULL;
//	
//	
//	    //如果查找的字符是结束符,直接用strchar 函数返回结束符号的位置。
//	
//	    if (c == '\0')
//	        return strchar (s, '\0');
//	
//	    //从当前字符串超找字符c,并将返回指针赋给p,如果p不等于NULL,则执行循环。
//	    //如果p等于NULL,说明已查找整个字符串,退出循环。
//	    while ( (p = strchar (s, c)) != NULL )
//	    {
//	
//	        found = p;
//	
//	        s = p + 1;
//	    }
//	
//	    //如果没有找到字符,则不会执行循环,found返回初值NULL。
//	    //如果找到字符,返回p赋给found的指针地址。
//	
//	    return (char *) found;
//	}

/************************************************************************
 * @function: Divu8
 * @描述: 两个8位数相除
 * 
 * @参数: 
 * @param: bediv 被除数
 * @param: div 除数
 * 
 * @返回: 
 * @return: Word16  商和余数
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
Word16 Divu8(uint8 bediv, uint8 div)
{
    uint8 end = 0;
    uint8 tail = div;
    Word16 result;

    result.word = 0;

    if(div == 0 || bediv == 0)          //除数为0就直接退出
    {
        return result;                  //返回结果为0
    }
                                        //先对除数进行移位
    while(!(tail & 0x80) && (tail < bediv))
    {
        tail <<= 1;
    }

    while(tail >= div)                  //当余数大于等于原始除数时总是执行
    {
        end <<= 1;

        if(tail <= bediv)               //如果余数大于当前除数
        {
            end |= 0x01;                //当前位置位
            bediv -= tail;              //让余数减去当前除数
        }
        tail >>= 1;                     //当前除数往后面移位
    }
    result.byte[0] = end;
    result.byte[1] = bediv;
    return result;                      //返回商

}


/************************************************************************
 * @function: Divu16
 * @描述: 两个16位数相除
 * 
 * @参数: 
 * @param: bediv 被除数
 * @param: div 除数
 * 
 * @返回: 
 * @return: Word32  商和余数
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
Word32 Divu16(uint16 bediv, uint16 div)
{
    uint16 end = 0;
    uint16 tail = div;
    Word32 result;

    result.lword = 0;

    if(div == 0 || bediv == 0)          //除数为0就直接退出
    {
        return result;                  //返回结果为0
    }
                                        //先对除数进行移位
    while(!(tail & 0x8000) && (tail < bediv))
    {
        tail <<= 1;
    }

    while(tail >= div)                  //当余数大于等于原始除数时总是执行
    {
        end <<= 1;

        if(tail <= bediv)               //如果余数大于当前除数
        {
            end |= 0x01;                //当前位置位
            bediv -= tail;              //让余数减去当前除数
        }
        tail >>= 1;                     //当前除数往后面移位
    }
    result.word[0] = end;
    result.word[1] = bediv;
    return result;                      //返回商

}


/************************************************************************
 * @function: ByteToInt
 * @描述: 将两字节的数据转换成一个16位的数
 * 
 * @参数: 
 * @param: byte 存放要转换的两个字节的缓存
 * 
 * @返回: 
 * @return: uint16  两个字节转换成16位数之后的结果
 * @说明: 比如byte[0] = 0x03, byte[1] = 0x02那么转换后的结果为0x0203
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 ByteToInt(uint8* byte)
{
    Word16 wd;                              //定义一个双字节联合体
    wd.byte[0] = byte[0];                   //第一个字节
    wd.byte[1] = byte[1];                   //第二个字节
    return wd.word;
}

/************************************************************************
 * @function: RByteToInt
 * @描述: 将两字节的数据转换成一个16位的数
 * 
 * @参数: 
 * @param: byte 存放要转换的两个字节的缓存
 * 
 * @返回: 
 * @return: uint16  两个字节转换成16位数之后的结果
 * @说明: 比如byte[0] = 0x03, byte[1] = 0x02那么转换后的结果为0x0203
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 RByteToInt(uint8* byte)
{
    Word16 wd;                              //定义一个双字节联合体
    wd.byte[0] = byte[1];                   //第一个字节
    wd.byte[1] = byte[0];                   //第二个字节
    return wd.word;
}


/************************************************************************
 * @function: ByteToLong
 * @描述: 四个字节转换成32位数
 * 
 * @参数: 
 * @param: byte 存放要转换的四个字节的缓存
 * 
 * @返回: 
 * @return: uint32  四个字节转换成32位数之后的结果
 * @说明: 比如byte[0] = 0x03, byte[1] = 0x02,
 *         byte[2] = 0x04, byte[3] = 0x05,
 *         那么转换后的结果为0x05040203
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 ByteToLong(uint8* byte)
{
    Word32 wd;
    wd.byte[0] = byte[0];                   //依次移动4个字节
    wd.byte[1] = byte[1];
    wd.byte[2] = byte[2];
    wd.byte[3] = byte[3];
    return wd.lword;
}
uint32 RByteToLong(uint8* byte)
{
    Word32 wd;
    wd.byte[0] = byte[3];                   //依次移动4个字节
    wd.byte[1] = byte[2];
    wd.byte[2] = byte[1];
    wd.byte[3] = byte[0];
    return wd.lword;
}


/************************************************************************
 * @function: ByteToInt24
 * @描述: 三个字节转换成24位数
 * 
 * @参数: 
 * @param: byte 存放要转换的三个字节的缓存
 * 
 * @返回: 
 * @return: uint32  三个字节转换成24位数之后的结果
 * @说明: 比如byte[0] = 0x03, byte[1] = 0x02, byte[2] = 0x04,
 *        那么转换后的结果为0x040203
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 ByteToInt24(uint8* byte)
{
    Word32 wd;
    wd.byte[0] = byte[0];                   //依次移动3个字节
    wd.byte[1] = byte[1];
    wd.byte[2] = byte[2];
    wd.byte[3] = 0;                         //最高字节无效
    return wd.lword;
}

/************************************************************************
 * @function: RByteToInt24
 * @描述: 三个字节转换成24位数
 * 
 * @参数: 
 * @param: byte 存放要转换的三个字节的缓存
 * 
 * @返回: 
 * @return: uint32  三个字节转换成24位数之后的结果
 * @说明: 比如byte[0] = 0x03, byte[1] = 0x02, byte[2] = 0x04,
 *        那么转换后的结果为0x040203
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 RByteToInt24(uint8* byte)
{
    Word32 wd;
    wd.byte[0] = byte[2];                   //依次移动3个字节
    wd.byte[1] = byte[1];
    wd.byte[2] = byte[0];
    wd.byte[3] = 0;                         //最高字节无效
    return wd.lword;
}


/************************************************************************
 * @function: IntToByte
 * @描述: 类型转换
 * 
 * @参数: 
 * @param: byte 存放转换后的两个字节的缓存
 * @param: value 需要转换的值
 * @返回: 
 * @说明: value = 0x0102,那么转换之后的结果为byte[0]=0x02, byte[1] = 0x01
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void IntToByte(uint8* byte, uint16 value)
{
    Word16* wd = (Word16*)&value;
    byte[0] = wd->byte[0];
    byte[1] = wd->byte[1];
}


/************************************************************************
 * @function: LongToByte
 * @描述: 类型转换
 * 
 * @参数: 
 * @param: byte 存放转换后的四个字节的缓存
 * @param: value 需要转换的值
 * @返回: 
 * @说明: 比如value = 0x01020304,那么转换之后的结果为byte[0]=0x04,
 *        byte[1] = 0x03,byte[2] = 0x02, byte[3] = 0x01
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void LongToByte(uint8* byte,  uint32 value)
{
    Word32* wd = (Word32*)&value;
    byte[0] = wd->byte[0];
    byte[1] = wd->byte[1];
    byte[2] = wd->byte[2];
    byte[3] = wd->byte[3];
}





/************************************************************************
 * @function: Int24ToByte
 * @描述: 类型转换
 * 
 * @参数: 
 * @param: byte 存放转换后的四个字节的缓存
 * @param: value 需要转换的值
 * @返回: 
 * @说明: 比如value = 0x010203,那么转换之后的结果为byte[0]=0x03,
 *        byte[1] = 0x02,byte[2] = 0x01
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Int24ToByte(uint8* byte,  uint32 value)
{
    Word32* wd = (Word32*)&value;
    byte[0] = wd->byte[0];
    byte[1] = wd->byte[1];
    byte[2] = wd->byte[2];
}






/************************************************************************
 * @function: ByteBcdToHex
 * @描述: 单字节BCD转换成HEX
 * 
 * @参数: 
 * @param: bcd 要转换的Bcd码
 * 
 * @返回: 
 * @return: uint8  将BCD码转换成HEX之后的结果
 * @说明: 比如输入0x12,输出12
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 ByteBcdToHex(uint8 bcd)
{
    uint8 result;
    result = bcd & 0x0F;                    //个位
    bcd >>= 4;
    result += bcd * 10;                     //十位
    return result;                          //返回结果
}


/************************************************************************
 * @function: ByteArrayBcdToHex
 * @描述: 多个字节BCD转换成HEX
 * 
 * @参数: 
 * @param: bcdary 要转换的Bcd数组
 * @param: hexary 输出的hex数组缓存
 * @param: len 要转换的字节数
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void ByteArrayBcdToHex(uint8* bcdary, uint8* hexary, uint32 len)
{
    for(uint32 i = 0; i < len; i++)
    {
        hexary[i] = ByteBcdToHex(bcdary[i]);  
    }
}



/************************************************************************
 * @function: IntBcdToHex
 * @描述: 双字节BCD转换成HEX
 * 
 * @参数: 
 * @param: bcd 要转换的Bcd码
 * 
 * @返回: 
 * @return: uint16  将BCD码转换成HEX之后的结果
 * @说明: 输入 0x1234,输出 1234
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 IntBcdToHex(uint16 bcd)
{
    Word16* wd = (Word16*)&bcd;             //将要转化的内容分成两个字节
    uint16 result;
    result = ByteBcdToHex(wd->byte[0]);     //个位和十位
                                            //百位和千位
    result += ((uint16)ByteBcdToHex(wd->byte[1])) * 100;
    return result;
}



/************************************************************************
 * @function: LongBcdToHex
 * @描述: 4字节BCD转换成HEX
 * 
 * @参数: 
 * @param: bcd 要转换的Bcd码
 * 
 * @返回: 
 * @return: uint32  将BCD码转换成HEX之后的结果
 * @说明: 输入 0x12345678,输出 12345678
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 LongBcdToHex(uint32 bcd)
{
    Word32* wd = (Word32*)&bcd;             //将要转换的内容分成2个字
    uint32 result;
    result = IntBcdToHex(wd->word[0]);      //个十百千
                                            //万十万百万千万
    result += IntBcdToHex(wd->word[1]) * 10000;
    return result;
}
/************************************************************************
 * @function: LongBcdToHex
 * @描述: 8字节BCD转换成HEX
 * 
 * @参数: 
 * @param: bcd 要转换的Bcd码
 * 
 * @返回: 
 * @return: uint64  将BCD码转换成HEX之后的结果
 * @说明: 输入 0x1234567812345678,输出 1234567812345678
 * @作者: yzy (2019/9/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint64 LongLongBcdToHex(uint64 bcd)
{
    Word64* wd = (Word32*)&bcd;             //将要转换的内容分成2个字
    uint64 result;
    result = LongBcdToHex(wd->lword[0]);      //个十百千
                                            //万十万百万千万
    result += LongBcdToHex(wd->lword[1]) * 100000000;
    return result;
}



//***********************************************************************
const uint8 gui_HexVar[7] =
{
	0x00, 0x16, 0x32, 0x48, 0x64, 0x80, 0x96,
};

/************************************************************************
 * @function: ByteHexToBcd
 * @描述: 单字节HEX转换成BCD
 * 
 * @参数: 
 * @param: hex 要转换的hex码 (hex < 100)
 * 
 * @返回: 
 * @return: uint8  将hex码转换成bcd之后的结果
 * @说明: 比如hex = 0x12, 那么转换后的结果为0x18
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 ByteHexToBcd(uint8 hex)
{
	uint8 t1, t2;
    if(hex > 99)						//不要超过0x99,超过的请调用函数IntHexToBcd
    {
    	return 0x99;
    }
	
	t1 = hex & 0x0F;					//取低4位进行转换
	
	if(t1 > 9)							//判断低4位是否需要进位
	{
		t1 += 6;
	}

	t2 = hex >> 4;
	t2 = gui_HexVar[t2];				//获取高四位对应的BCD码的数值

    hex = t1;
	t1 = (hex & 0x0F) + (t2 & 0x0F);	//低四位
	t2 = (hex & 0xF0) + (t2 & 0xF0);	//高四位
	
	if(t1 > 9)							//低四位的进位判断
	{
		t1 += 6;
	}
	
	return t1 + t2;						//返回转换好的结果
	
}




/************************************************************************
 * @function: ByteArrayHexToBcd
 * @描述: 多字节HEX转换成HEX
 * 
 * @参数: 
 * @param: hexary 需要转换的数据
 * @param: bcdary 转换好的字节数组
 * @param: len 需要转换的数据的长度
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void ByteArrayHexToBcd(uint8* hexary, uint8* bcdary, uint32 len)
{ 
    for(uint32 i = 0; i < len; i++)
    {
        bcdary[i] = ByteHexToBcd(hexary[i]);  
    }  
}



/************************************************************************
 * @function: IntHexToBcd
 * @描述: 双字节HEX转换成BCD
 * 
 * @参数: 
 * @param: hex 要转换的hex码(hex < 10000)
 * 
 * @返回: 
 * @return: uint16  将hex码转换成bcd之后的结果
 * @说明: 输入 1234 ,输出 0x1234 
 *	      采用模拟除以100的方法来进行转换
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 IntHexToBcd(uint16 hex)
{
	uint16 result = 0;

	if(hex > 9999)
	{
		return 0x9999;
	}

	if(hex >= 8000)
	{
		result |= 0x8000;
		hex -= 8000;
	}

	if(hex >= 4000)
	{
		result |= 0x4000;
		hex -= 4000;
	}

	if(hex >= 2000)
	{
		result |= 0x2000;
		hex -= 2000;		
	}

	if(hex >= 1000)
	{
		result |= 0x1000;
		hex -= 1000;
	}

	if(hex >= 800)
	{
		result |= 0x800;
		hex -= 800;
	}

	if(hex >= 400)
	{
		result |= 0x400;
		hex -= 400;
	}

	if(hex >= 200)
	{
		result |= 0x200;
		hex -= 200;		
	}

	if(hex >= 100)
	{
		result |= 0x100;
		hex -= 100;
	}

	result |= ByteHexToBcd(hex);
	return result;
	
}


/************************************************************************
 * @function: LongHexToBcd
 * @描述: 4字节HEX转换成BCD
 * 
 * @参数: 
 * @param: hex 要转换的hex码(hex < 100000000)
 * 
 * @返回: 
 * @return: uint32  将hex码转换成bcd之后的结果
 * @说明: 输入 1234567 输出 0x1234567
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 LongHexToBcd(uint32 hex)
{
    uint32 result = 0;
	uint32 cmp, bitcap;
	uint8 uc_i;

	if(hex > 99999999)
	{
		return 0x99999999;
	}

	for(cmp = 80000000, bitcap = 0x80000000, uc_i = 0; uc_i < 16; uc_i++)
	{
		if(hex >= cmp)
		{
			result |= bitcap;
			hex -= cmp;
		}
		bitcap >>= 1;
		switch(uc_i)
		{
			case 3:
				cmp = 8000000;
				break;
			case 7:
				cmp = 800000;
				break;
			case 11:
				cmp = 80000;
				break;
			default:
				cmp >>= 1;
		}
	}

	result |= IntHexToBcd(hex);
	return result;
}



/************************************************************************
 * @function: BcdToHex
 * @描述: 将指定字节数的BCD码转换成指定字节数的HEX码
 * 
 * @参数: 
 * @param: bcd 要转换的BCD码的存放位置
 * @param: hex 转换后的HEX码存放的位置
 * @param: nbcd 要转换的BCD码的字节数(<=5)
 * @param: nhex 转换后的HEX码的字节数(<=4)
 * @返回: 
 * @说明: 比如bcd[0] = 0x55, bcd[1] = 0x02, nbcd = 2, nhex = 1,
 *        那么转换后的结果为 hex[0] = 0xff(bcd 可以等于 hex)
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void BcdToHex(uint8* bcd, uint8* hex, uint8 nbcd, uint8 nhex)
{
    uint8 uc_i;
    Word32 result;
    if(nbcd > 5 || nhex > 4)                //检查长度的合法性
    {
        return;
    }
    result.lword = 0;                       //初始化

    for(uc_i = nbcd; uc_i > 0; uc_i --)     //循环一个字节一个字节的进行转换
    {
                                            //转换
        result.lword = result.lword * 100 + ByteBcdToHex(bcd[uc_i - 1]);
    }
    MoveBuffer(result.byte, hex, nhex);     //移动到最终的缓存
}



/************************************************************************
 * @function: HexToBcd
 * @描述: 将指定字节数的hex码转换成指定字节数的BCD码
 * 
 * @参数: 
 * @param: bcd 转换后的BCD码的存放位置
 * @param: hex 要转换的HEX码存放的位置
 * @param: nbcd 转换后的BCD码的字节数 (<=5)
 * @param: nhex 要转换的HEX码的字节数 (<=4)
 * @返回: 
 * @说明: 比如hex[0] = 255, nhex = 1, nbcd =2, 那么转换后的结果为
 *          Bcd[0] = 0x55, bcd[1] = 0x02
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void HexToBcd(uint8* bcd, uint32 hex, uint8 nbcd, uint8 nhex)
{
    uint8 byte[5];

    if(nbcd > 5 || nhex > 4)                //检查长度的合法性
    {
        return;
    }
                                            //最高位
    byte[4] = 0;

	if(hex >= 4000000000ul)					//40亿
	{
		byte[4] |= 0x40;
		hex -= 4000000000ul;
	}

	if(hex >= 2000000000ul)					//20亿
	{
		byte[4] |= 0x20;
		hex -= 2000000000ul;
	}

	if(hex >= 1000000000ul)					//10亿
	{
		byte[4] |= 0x10;
		hex -= 1000000000ul;
	}

	if(hex >= 800000000ul)					//8亿
	{
		byte[4] |= 0x08;
		hex -= 800000000ul;
	}

	if(hex >= 400000000ul)					//4亿
	{
		byte[4] |= 0x04;
		hex -= 400000000ul;
	}

	if(hex >= 200000000ul)					//2亿
	{
		byte[4] |= 0x02;
		hex -= 200000000ul;
	}
	if(hex >= 100000000ul)					//1亿
	{
		byte[4] |= 0x01;
		hex -= 100000000ul;
	}
												
                                            //转换字节
    LongToByte(byte, LongHexToBcd(hex));
    MoveBuffer(byte, bcd, nbcd);            //将结果转移到最终的寄存器
}



/************************************************************************
 * @function: IsHexChar
 * @描述: 判断ch是否属于合法的字符格式的hex码
 * 
 * @参数: 
 * @param: ch 需要判断的字符
 * 
 * @返回: 
 * @return: uint8  true: ch是'0'-'9','A'-'F','a'-'f'中的成员
 *                false: ch不是'0'-'9','A'-'F','a'-'f'中的成员
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 IsHexChar(uint8 ch)
{
    if((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f')
        || (ch >= 'A' && ch <= 'F'))
    {
        return true;
    }
    return false;
}

uint8 IsAsciiChar(uint8 ch)
{
    if((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z')
        || (ch >= 'A' && ch <= 'Z'))
    {
        return true;
    }
    return false;
}

/************************************************************************
 * @function: IsBcd
 * @描述: 判断是否属于合法的压缩型的BCD码
 * 
 * @参数: 
 * @param: bcd 需要判断的字符
 * 
 * @返回: 
 * @return: uint8  true
 *                false
 * @说明: 比如bcd=0xA5,返回false,bcd=0x55,返回true
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 IsBcd(uint32 bcd)
{
    for(uint8 uc_i = 0; uc_i < 8; uc_i++)
    {
        if((bcd & 0x0f) > 9)
        {
            return false;
        }
        bcd >>= 4;
    }
    
    return true;
}


/************************************************************************
 * @function: IsBcdChar
 * @描述: 判断ch是否属于合法的字符格式的BCD码
 * 
 * @参数: 
 * @param: ch 需要判断的字符
 * 
 * @返回: 
 * @return: uint8  true: ch是'0'-'9'中的成员
 *                false: ch不是'0'-'9'中的成员
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 IsBcdChar(uint8 ch)
{
    if(ch >= '0' && ch <= '9')
    {
        return true;
    }
    return false;
}



/************************************************************************
 * @function: HexCharToValue
 * @描述: 数值转换
 * 
 * @参数: 
 * @param: ch 需要转换的字符
 * 
 * @返回: 
 * @return: uint8  Ch如果是'0'-'9','A'-'F','a'-'f'中的成员那么输出其转换后的值,
 *                 否则输出0xFF表示无法转换
 * @说明: 比如ch = 'a', 那么转换后是0x0A, 如果ch = 0x01,那么将返回0xff
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 HexCharToValue(uint8 ch)
{
    if(ch >= '0' && ch <= '9')
    {
        ch -= '0';                          //0-9
    }
    else if(ch >= 'a' && ch <= 'f')
    {
        ch -= 'a' - 10;                     //a-f
    }
    else if(ch >= 'A' && ch <= 'F')
    {
        ch -= 'A' - 10;                     //A-F
    }
    else
    {
        ch = 0xFF;                          //无效
    }
    return ch;                              //返回最终结果
}


/************************************************************************
 * @function: ValueToHexChar
 * @描述: HexCharToValue的反运算
 * 
 * @参数: 
 * @param: val 要转换的值.范围0-0x0f 
 * @param: iscap 输出的ascii是否为大写 
 * 
 * @返回: 
 * @return: uint8  0xFF:无法转换 
 *         如val=11, 若iscap为真则输出'B';为假,则输出'b'.
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 ValueToHexChar(uint8 val, uint8 iscap)
{
    if(val <= 9)
    {
        val += '0';                          //0-9
    }
    else if(val >= 0x0A && val <= 0x0F)
    {
        if(iscap)
        {
            val += 'A' - 10;                //A-F
        }
        else
        { 
            val += 'a' - 10;                //a-f
        }
    }
    else
    {
        val = 0xFF;                         //无效
    }

    return val;                             //返回最终结果
}


/************************************************************************
 * @function: BcdCharToValue
 * @描述: 数值转换
 * 
 * @参数: 
 * @param: ch 需要转换的字符
 * 
 * @返回: 
 * @return: uint8  Ch如果是'0'-'9'中的成员那么输出其转后的值,否则输出0xFF表示无法转换
 * @说明: 比如ch = '9',那么转换后是0x09, 如果ch ='a',那么将返回0xff表示无法转换
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 BcdCharToValue(uint8 ch)
{
    if(ch >= '0' && ch <= '9')
    {
        ch -= '0';                          //0-9
    }
    else
    {
        ch = 0xFF;                          //无效
    }
    return ch;                              //返回最终结果
}









/************************************************************************
 * @function: BcdStringToNum
 * @描述: BCD格式字符串表示为数值
 * 
 * @参数: 
 * @param: ch 需要转换的字符串
 * @param: length 需要转换的字符串的长度(<=9)
 * 
 * @返回: 
 * @return: uint32  0－999999999转换后的结果,>999999999无法转换
 * @说明: 比如ch[0] = '2',ch[1] = '1', ch[2] = '3',
 *        length = 3那么转换后的结果为213; 如果ch[0] = 'f',
 *        那么将返回1000000000
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 BcdStringToNum(uint8* ch, uint8 length)
{
    uint8 uc_i, chr;
    uint32 result;

    if(length > 9)                          //长度不能太长
    {
        return 1000000000;
    }

    for(result = 0, uc_i = 0; uc_i < length; uc_i ++)
    {                                       //判断要转换的字符的正确性
        if((chr = BcdCharToValue(ch[uc_i ])) == 0xFF)
        {
            return 1000000000;               //字符不正确就马上返回
        }
        result = result * 10 + chr;         //每个字符都递增
    }
    return result;                          //返回转换好的结果
}



/************************************************************************
 * @function: NumToBcdString
 * @描述: 数值表示为BCD格式字符串
 * 
 * @参数: 
 * @param: ch 转换后的字符串
 * @param: num 需要转换的数
 * @param: format 表示是否需要格式化转换 0:不需要
 *                  1-9转换后的字符长度,如果不足,前面的字节用0代替
 * 
 * @返回: 
 * @return: uint8  1-9转换后的有效长度.
 * @说明: byte = 56,format = 0,那么转换后的结果为 ch[0] = '5', ch[1] = '6', 返回值为2
 *        byte = 56, format = 8, 那么转换后的结果为ch[0]~ch[5] = '0',
 *        ch[6] = '5', ch[7] = '6', 返回值为2
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 NumToBcdString(uint8* ch, uint32 num, uint8 format)
{
    uint8 data[9];                          //临时缓存用于存放转换后的9个字符
    uint8 temp[5];                          //临时用于存放转换成BCD码后的5个字节
    uint8 uc_i, mark;                       //循环变量和开始标记

    HexToBcd(temp, num, 5, 4);              //将num转换成Bcd码

    for(uc_i = 0, mark = 0; uc_i < 9; uc_i ++)
    {                                       //循环将BCD码转换成字符
        if(uc_i & 0x01)                     //高4位
        {
            data[uc_i] = (temp[uc_i >> 1] >> 4) + '0';
        }
        else                                //低四位
        {
            data[uc_i] = (temp[uc_i >> 1] & 0x0F) + '0';
        }
        if(data[uc_i] != '0')               //标记从哪里开始后都是'0'了
        {
            mark = uc_i + 1;
        }
    }
    if(mark == 0)
    {
        mark++;
    }

    if(format == 0)                         //如果不需要格式化
    {
        format = mark;                      //等价于有几个字符就格式化成几个字符
    }

    if( format <= 9)                        //格式化字符串
    {
        MoveBuffer(data, ch, format);       //移动字符串
        InvBuffer(ch, format);              //反转字符串,方便阅读
    }
    return mark;                           //返回有效字符
}


/************************************************************************
 * @function: HexStringToNum
 * @描述: HEX格式字符串表示为数值
 * 
 * @参数: 
 * @param: ch 需要转换的字符串
 * @param: byte 转换后的字节数组
 * @param: length 一共要转换的字符数(偶数才是合法的)
 * 
 * @返回: 
 * @return: uint8  true 转换成功
 *	              false 转换失败
 * @说明: 比如 ch = "567F",那么转换之后的结果为byte[0] = 0x56,byte[1] = 0x7F
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 HexStringToNum(uint8* ch, uint8* byte, uint16 length)
{
    uint16 ui_i;                            //循环变量
    uint8 temp;                             //临时变量用于暂存字符转换后的值

    if(length & 0x01)                       //长度需要是偶数才能进行有效转换
    {
        return false;
    }

    for(ui_i = 0; ui_i < length; ui_i ++)   //逐个字符进行转换
    {
                                            //16进制字符转换成值
        if((temp = HexCharToValue(ch[ui_i])) == 0xFF)
        {
            return false;
        }
        if(ui_i & 0x01)                     //判断高低四位
        {
            byte[ui_i >> 1] += temp;        //高四位
        }
        else
        {
            byte[ui_i >> 1] = temp << 4;    //低四位
        }
    }
    return true;                            //返回转换成功
}




/************************************************************************
 * @function: NumToHexString
 * @描述: 数值表示为BCD格式字符串
 * 
 * @参数: 
 * @param: ch 转换后的字符串
 * @param: byte 需要转换的字节数组
 * @param: length 一共要转换的字节数
 * 
 * @返回: 
 * @return: uint8 0成功.其他失败
 * @说明: 刚好是HexStringToNum的逆过程
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 NumToHexString(uint8* ch, uint8* byte, uint16 length)
{
    uint16 ui_i, ui_j;                      //循环变量用于转换
    uint8 chr;
                                            //循环
    for(ui_i = 0, ui_j = 0; ui_j < (length << 1); ui_j ++ )
    {
        if(ui_j & 0x01)                     //高4位
        {
            chr = byte[ui_i] & 0x0F;
            ui_i ++;
        }
        else                                //低四位
        {
            chr = byte[ui_i] >> 4;
        }

        chr += (chr <= 9) ? '0': 'A' - 0x0A;      //将4位值转换成字符
        ch[ui_j] = chr;                     //...
    }

    return 0;                               //返回转换成功
}




/************************************************************************
 * @function: ByteArrayBcdToHexString
 * @描述: 将BCD字节串转成ascii
 * 
 * @参数: 
 * @param: bcdary 需要转换的数据
 * @param: ascii 转换好的字符串
 * @param: len 需要转换的数据的长度
 * @param: big 是否big-endian输出
 * @返回: 
 * @说明: 如 hexary[0] = 0x01, hexary[1] = 0x0A, len = 2, 
 *       若big为真,输出ascii[0]-[3]为 '0' '1' '0' 'A' 
 *       若big为假,输出ascii[0]-[3]为 '0' 'A' '0' '1'
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void ByteArrayBcdToHexString(uint8* bcdary, uint8* ascii, uint32 len, uint8 big)
{
    for(uint8 uc_i = 0; uc_i < len; uc_i++)
    {
        if(big)
        {
            ascii[(uc_i << 1)] = ValueToHexChar(bcdary[uc_i] >> 4, true);
            ascii[(uc_i << 1) + 1] = ValueToHexChar(bcdary[uc_i] & 0x0F, true);
        }
        else
        {
            ascii[((len - uc_i - 1) << 1)] = ValueToHexChar(bcdary[uc_i] >> 4, true);
            ascii[((len - uc_i - 1) << 1) + 1] = ValueToHexChar(bcdary[uc_i] & 0x0F, true);
        }
    }
}
















/************************************************************************
 * @function: AbsVal
 * @描述: 
 * 
 * @参数: 
 * @param: value 原数据
 * 
 * @返回: 
 * @return: uint32  绝对值
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 AbsVal(int32 value)
{
    if(value < 0)                       //如果小于0
    {
        value =- value;                 //取相反数
    }
    return value;                       //返回结果
}

/************************************************************************
 * @function: AbsVal64
 * @描述: 
 * 
 * @参数: 
 * @param: value 原数据
 * 
 * @返回: 
 * @return: uint32  绝对值
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint64 AbsVal64(int64 value)
{
    if(value < 0)                       //如果小于0
    {
        value =- value;                 //取相反数
    }
    return value;                       //返回结果
}




/************************************************************************
 * @function: DoSum
 * @描述: 累加和计算
 * 
 * @参数: 
 * @param: buff 需要计算累加和的字符数组
 * @param: length 需要计算累加和的字节数
 * 
 * @返回: 
 * @return: uint16  计算后的累加和
 * @说明: 计算后的累加和,大于65536将自动溢出
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 DoSum(uint8* buff, uint16 length)
{
    uint16 result = 0;                      //赋初值

    while(length --)                        //逐个字节进行累加
    {
        result += *buff ++;
    }
    return result;                          //返回结果
}


/************************************************************************
 * @function: DoBitSum
 * @描述: 位加和计算
 * 
 * @参数: 
 * @param: buff 需要计算位加和(异或)的字符数组
 * @param: length 需要计算位加和的字节数
 * 
 * @返回: 
 * @return: uint8  计算后的位加和
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 DoBitSum(uint8* buff, uint16 length)
{
    uint8 result = 0;                       //赋初值

    while(length --)                        //逐个字节进行位加
    {
        result ^= *buff ++;
    }
    return result;                          //返回最终结果
}


/************************************************************************
 * CRC16查询表
 ************************************************************************/
const uint16 CRC16_Table[256] =
{
   0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
   0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
   0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
   0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
   0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
   0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
   0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
   0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
   0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
   0xC9CC, 0xD9ED, 0xE98E, 0xF9Af, 0x8948, 0x9969, 0xA90A, 0xB92B,
   0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
   0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
   0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
   0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
   0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
   0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
   0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
   0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
   0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
   0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
   0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
   0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
   0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
   0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
   0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
   0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
   0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
   0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0Af1, 0x1AD0, 0x2AB3, 0x3A92,
   0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
   0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
   0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
   0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0,
};

/************************************************************************
 * @function: DoCrc16
 * @描述: CRC16校验和计算
 * 
 * @参数: 
 * @param: buff 需要计算CRC16的字节数组
 * @param: length 需要计算CRC16的字节数
 * @param: init 计算CRC16的初始值
 * 
 * @返回: 
 * @return: uint16  计算后的CRC值
 * @说明: 多项式 X16 + X12 + X5 + X1
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 DoCrc16(uint8* buff, uint16 length, uint16 init)
{
    uint16 ui_i;                            //循环变量
    uint8  temp;                            //临时变量
    Word16 wd;                              //中间运算值

    wd.word = init;                         //赋初值

    for(ui_i = 0; ui_i < length; ui_i ++)   //循环计算CRC
    {
        temp = wd.byte[1] ^ buff[ui_i];     //获取索引
        wd.byte[1] = wd.byte[0];
        wd.byte[0] = 0;
        wd.word ^= CRC16_Table[temp];       //结果
    }
    return wd.word;                         //返回最终结果
}





/************************************************************************
 * DLMS_CRC16查询表
 ************************************************************************/
const uint16 dlms_crc_tab[256] = 
{
    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/************************************************************************
 * @function: DoCrcDlms
 * @描述: DLMS帧的crc计算函数
 * 
 * @参数: 
 * @param: buffer 
 * @param: length 
 * @param: init 
 * 
 * @返回: 
 * @return: uint16  
 * @说明: 
 * @作者: yzy (2014/5/26)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 DoCrcDlms(uint8* buffer, uint16 length, uint16 init)
{
	if(init != 0xffff)
    {
        init ^= 0xffff;
    }

    for(uint16 i = 0; i < length; i++)
    {
        init = (init >> 8) ^ dlms_crc_tab[ (init ^ *(buffer + i) ) & 0xff];
    }

    return (init ^ 0xffff);
}

uint16_t DoCrcRtuModbus(uint8_t *buf,uint16_t trans_length,uint16_t crc) //bb
{ 
    uint16_t i,j,TT;
    for (i=0;i<trans_length;i++) 
    {
        crc = crc ^ buf[i];
        for(j = 0; j < 8; j ++)
        {
            TT = crc & 1;
            crc = crc  >> 1;
            crc = crc  & 0x7fff;
            if(TT == 1)   crc = crc ^ 0xa001;
            crc = crc & 0xffff;
        }
    }
    return crc;
}


/************************************************************************
 * @function: CalcWeek
 * @描述: 根据时间计算星期(以07年1月1日为基准,07年1月1日星期一)
 * 
 * @参数: 
 * @param: date 日月年,HEX 
 * 
 * @返回: 
 * @return: uint8  星期(0-6,星期天为0).
 *                  0xFF表示输入格式有误
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 CalcWeek(uint8* date, uint8 start)
{
    const uint8* monthday;
    uint16 dyear;
    uint16 tday;
    uint8 dweek;
    
    if(date[2] < 7 || date[2] > 99)     //年的合法性
    {
        return 0xFF;
    }
    
    if((date[2] & 0x03) == 0)           //判断今年是否为闰年
    {
        monthday = guc_BYearMonth;
    }
    else
    {
        monthday = guc_LYearMonth;  
    }
    
    if(date[1] == 0 || date[1] > 12)    //月的合法性
    {
        return 0xFF;
    }
                                        //日的合法性
    if(date[0] == 0 || date[0] > monthday[date[1] - 1])
    {
        return 0xFF;
    }
    
    tday = (date[2] - 7) * 365;         //年
    tday += (date[2] - 4) >> 2;         //加上闰年的天
    if(!(date[2] & 0x03) && date[1] < 3)//闰年还没有过2月
    {
        tday--;                         //减少一天
    }
                                        //当前为一年中的第几天
    dyear = gui_MonthBeginDay[date[1] - 1] + date[0] - 1;
    dweek = Divu16(tday + dyear, 7).word[1] + 1;
    if(dweek == 7 && start == 0)
    {
        dweek = 0;
    }
    return dweek;
}



 


/************************************************************************
 * @function: CalcDayHex
 * @描述: 计算指定时刻的总天数(以00年1月1日为基准)
 * 
 * @参数: 
 * @param: year 年
 * @param: month 月
 * @param: day 日
 * 
 * @返回: 
 * @return: uint16  将所有的数据转换成天之后的值
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 CalcDayHex(uint8 year, uint8 month, uint8 day)
{
    uint16 result;							//结果 
    result = year * 365;					//乘上若干年
    result += year >> 2;					//加上过去的整4年的闰年的一天
    if((year & 0x03) > 0 || month > 2)		//判断是否过了闰年的2月
    {
        result++;							//再加一天
    }
    result += gui_MonthBeginDay[month - 1];	//加上月份的偏移
    result += day - 1;						//加上日期的偏移	
    return result;
} 





/************************************************************************
 * @function: CalcHourHex
 * @描述: 计算指定时刻的总小时数
 * 
 * @参数: 
 * @param: year 年,hex
 * @param: month 月
 * @param: day 日
 * @param: hour 时
 * 
 * @返回: 
 * @return: uint32  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 CalcHourHex(uint8 year, uint8 month, uint8 day, uint8 hour)
{
	uint32 result;
    result = CalcDayHex(year, month, day) * 24 + hour;
	return result;
}






/************************************************************************
 * @function: CalcMinuteHex
 * @描述: 计算指定时刻的总分种数
 * 
 * @参数: 
 * @param: year 年,hex
 * @param: month 月
 * @param: day 日
 * @param: hour 时
 * @param: mins 分
 * 
 * @返回: 
 * @return: uint32  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: yzy
 * 更改函数原型
 ************************************************************************/
uint32 CalcMinuteHex(uint8 year, uint8 month, uint8 day, uint8 hour, uint8 mins)
{
	uint32 result;
	result = (uint32)CalcDayHex(year, month, day) * gui_DayMinCount + hour * 60 + mins;
	return result;
}




/************************************************************************
 * @function: CalcMins
 * @描述: 计算指定时刻的总分种数
 * 
 * @参数: 
 * @param: time B0-B4:分时日月年
 * @param: isbcd 1bcd,0hex
 * 
 * @返回: 
 * @return: uint32  将所有的数据转换成分之后的值
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 CalcMins(uint8* time, uint8 isbcd)
{
    uint8 hextime[5];
    uint32 result;
    
    MoveBuffer(time, hextime, 5);
    
    if(isbcd)
    {
        ByteArrayBcdToHex(hextime, hextime, 5); 
    }

    result = CalcHourHex(hextime[4], hextime[3], hextime[2], hextime[1]) * 60 + hextime[0];
    
    return result;
}



 


/************************************************************************
 * @function: CalcSecs
 * @描述: 计算指定时刻的总秒数
 * 
 * @参数: 
 * @param: time B0-B5:秒分时日月年
 * @param: isbcd 1bcd,0hex
 * 
 * @返回: 
 * @return: uint32  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 CalcSecs(uint8* time, uint8 isbcd)
{
    uint8 hextime[6];
    uint32 result;
    
    MoveBuffer(time, hextime, 6);
    if(isbcd)
    {
        ByteArrayBcdToHex(hextime, hextime, 6);
    } 
	
	result = hextime[3] * gul_DaySecCount;	//＋整天的秒
	result += hextime[2] * gui_HourSecCount;//＋整时的秒
	result += hextime[1] * 60;				//＋整分的秒
	result +=  hextime[0];					//零头
	return result;							//返回结果 
}




/************************************************************************
 * @function: CalcTimeFromMins
 * @描述: CalcMins()反函数
 * 
 * @参数: 
 * @param: out B0-B4:mmHHDDMMYY,hex
 * @param: mins 总分钟数 
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void CalcTimeFromMins(uint8* out, uint32 mins)
{
    uint16 days;                    //总天数
    uint8 time[5];                  //mmHHDDMMYY
    const uint8* pMonArray;         //月天数阵列指针

    days = mins / 1440;             //天
    mins %= 1440;                   //剩余分钟
                                    //年
    time[4] = (days / 1461) << 2;   //1461 = 366+365+365+365
    days %= 1461;
    if(days >= 366)
    {
        days -= 366;
        time[4] += (1 + days / 365);
        days %= 365;
    }
                                    //月
    pMonArray = (((time[4] & 3) == 0) ? guc_BYearMonth : guc_LYearMonth);

    time[3] = 1;                    //月份从1月开始
    for(uint8 uc_i = 0; uc_i < 12; uc_i++)
    {
        if(days >= pMonArray[uc_i])
        {
            days -= pMonArray[uc_i];
            time[3]++;
        }
        else
        {
            break;
        }
    }

    time[2] = days + 1;             //计算日,日从1号开始
    time[1] = mins / 60;            //计算小时
    time[0] = mins % 60;            //计算分钟

    MoveBuffer(time, out, 5);       //输出

}


/************************************************************************
 * @function: CalcTimeFromSecs
 * @描述: CalcSecs()反函数
 * 
 * @参数: 
 * @param: out B0-B5:ssmmHHDDMMYY,hex
 * @param: secs 分钟数 
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void CalcTimeFromSecs(uint8* out, uint32 secs)
{
    uint32 mins;
    mins = secs / 60;
    
    out[0] = secs % 60;                 //秒
    CalcTimeFromMins(out + 1, mins);    //分时日月年
    
}




/************************************************************************
 * @function: U16_little_big_endian
 * @描述: 从little_endian的形式转换到big_endian的形式
 * 
 * @参数: 
 * @param: little little_endian的表现形式
 * 
 * @返回: 
 * @return: uint16 big_endian的表现形式 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 U16_little_big_endian(uint16 little)
{
	return (little >> 8) | (little << 8);
}




/************************************************************************
**函数名uint8bool StepMins(uint8* time, int32 step)
**描 述: 对时间进行分步进
**
**输 入: time YYMMDDHHmm(hex,年在前)
         step 步进的分钟数
**输 出: true成功 false失败
**
**备 注: 如time指向 08-01-31 23:59:01,step = 15,则输出time为 08-02-01 00:14:01
**--------------------------------------------------------
**作 者: yzy
**日 期: 2009-5-5
*************************************************************************/
uint8 StepMins(uint8* time, int32 step)
{
    uint32 mins;
    uint8 tmp[5];

    MoveBuffer(time, tmp, 5);
                                    //计算步进前分钟
    InvBuffer(tmp, 5);
    mins = CalcMins(tmp, false);
    if(step < 0)                    //步进范围合理性判断
    {
        if(mins < -step)            //处理后时标小于2000-01-01
        {
            return false;
        }
    }
    else
    {
        if(mins > 52596000 - step)  //处理后时标小于2100-01-01零时
        {
            return false;
        }
    }
    mins += step;                   //步进处理
    CalcTimeFromMins(tmp, mins);
    InvBuffer(tmp, 5);

    MoveBuffer(tmp, time, 5);       //输出

    return true;

}


/************************************************************************
 * @function: U32_little_big_endian
 * @描述: 从little_endian的形式转换到big_endian的形式
 * 
 * @参数: 
 * @param: little little_endian的表现形式
 * 
 * @返回: 
 * @return: uint32  big_endian的表现形式
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 U32_little_big_endian(uint32 little)
{
	Word32 l, b;
	l.lword = little;
	b.byte[0] = l.byte[3];
	b.byte[1] = l.byte[2];
	b.byte[2] = l.byte[1];
	b.byte[3] = l.byte[0];
	return b.lword;
}


/************************************************************************
 * @function: CheckBufferCRC
 * @描述: 验证缓存中的CRC
 * 
 * @参数: 
 * @param: buffer 缓存
 * @param: size 缓存的大小
 * @param: end true CRC值在缓存结尾,false CRC值在缓存开头
 * 
 * @返回: 
 * @return: uint8  true 验证成功
 *                false 验证失败
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 CheckBufferCRC(uint8* buffer, uint16 size, uint8 end)
{
    uint16 crc;                         //CRC值

    if(size < 2)                        //如果缓存大小小于2则错误
    {
        return false;
    }

    if(end)                             //是否在结尾
    {
                                        //获取CRC值
        crc = ByteToInt(buffer + size - 2);
    }
    else                                //在开头
    {
        crc = ByteToInt(buffer);        //获取CRC值
        buffer += 2;                    //缓存后移
    }
    return crc == DoCrc16(buffer, size - 2, 0x5555);
}



/************************************************************************
 * @function: BuildBufferCRC
 * @描述: 建立缓存中的CRC
 * 
 * @参数: 
 * @param: buffer 缓存
 * @param: size 缓存的大小
 * @param: end true CRC值在缓存结尾,false CRC值在缓存开头
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void BuildBufferCRC(uint8* buffer, uint16 size, uint8 end)
{
    uint16 crc;                         //CRC值

    if(size < 2)                        //如果缓存大小小于2则错误
    {
        return;
    }

    if(end)                             //是否在结尾
    {
                                        //获取CRC值
        crc = DoCrc16(buffer, size - 2, 0x5555);
        buffer += size - 2;
    }
    else                                //在开头
    {
        crc = DoCrc16(buffer + 2, size - 2, 0x5555);
    }
    
    IntToByte(buffer, crc);             //转换结果
}


/************************************************************************
 * @function: sqrt_16
 * @描述: 开根号处理
 * 
 * @参数: 
 * @param: M 长整型
 * 
 * @返回: 
 * @return: uint16 整型 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 sqrt_16(uint32 M)
{
    uint16 rst, i;
    uint32 tmp, ttp;                    // 结果、循环计数
    if (M == 0)
        return 0;

    rst = 0;

    tmp = (M >> 30);
    M <<= 2;
    if (tmp > 0)
    {
        rst ++;
        tmp -= rst;
    }

    for (i=15; i>0; i--)
   {
        rst <<= 1;                      // 左移一位

        tmp <<= 2;
        tmp += (M >> 30);

        ttp = rst;                      // uint32
        ttp = (ttp<<1)+1;

        M <<= 2;
        if (tmp >= ttp)
        {
            tmp -= ttp;                 // 假设成立
            rst ++;
        }

    }

    return rst;
}






/************************************************************************
 * @function: MidWaySearch
 * @描述: 中值法搜索想要的内容,Key为uint16类型
 * 
 * @参数: 
 * @param: pdata 需要搜索的内容.为目标结构体的数组的起始位置.结构体第一个元素必须是序号,uint16类型
 * @param: size 结构体总数
 * @param: len 每个结构体的长度
 * @param: id 目标序号
 * 
 * @返回: 
 * @return: uint16  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 MidWaySearch(uint8* pdata, uint16 size, uint16 len, uint16 id)
{
    uint16 mid, min, max, cmp;
    min = 0;
    max = size - 1;

    if(len == 0)
    {
        return 0xFFFF;
    }
    
    while(1)
    {
        mid = (min + max) / 2;
                                        //获取待比较的数据
        cmp = pdata[mid * len] + (pdata[mid * len + 1] << 8);

        if (id == cmp)                  // 找到相等数据
        {
            break;
        }
        else if (id > cmp)              // 查找数据比找到的数据大
        {
            if (mid == max)             // 已经查完
            {
                mid = 0xffff;           // 没找到
                break;
            }
            min = mid + 1;
        }
        else                            // 查找数据比找到的数据小
        {
            if (mid == min)             // 已经查完
            {
                mid = 0xffff;           // 没找到
                break;
            }
            max = mid - 1;
        }
    }

    return mid;
}



/************************************************************************
 * @function: LongMidWaySearch
 * @描述: 中值法搜索想要的内容,Key为长整形
 * 
 * @参数: 
 * @param: pdata 需要搜索的内容.为目标结构体的数组的起始位置.结构体第一个元素必须是序号,uint32类型
 * @param: size 结构体总数
 * @param: len 每个结构体的长度
 * @param: id 目标序号
 * 
 * @返回: 
 * @return: uint16  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 LongMidWaySearch(uint8* pdata, uint16 size, uint16 len, uint32 id)
{
    uint16 mid, min, max;
    uint32 cmp;
    min = 0;
    max = size - 1;

    if(len == 0)
    {
        return 0xFFFF;
    }

    while(1)
    {
        mid = (min + max) / 2;
                                        //获取待比较的数据
        cmp = *((uint32*)(pdata + mid * len));

        if (id == cmp)                  // 找到相等数据
        {
            break;
        }
        else if (id > cmp)              // 查找数据比找到的数据大
        {
            if (mid == max)             // 已经查完
            {
                mid = 0xffff;           // 没找到
                break;
            }
            min = mid + 1;
        }
        else                            // 查找数据比找到的数据小
        {
            if (mid == min)             // 已经查完
            {
                mid = 0xffff;           // 没找到
                break;
            }
            max = mid - 1;
        }
    }

    return mid;
}



/************************************************************************
 * @function: ADVMidWaySearch
 * @描述: 加强的中值法搜索想要的内容.即在中值法查找基础上,增加同类项支持
 * 
 * @参数: 
 * @param: pdata 需要搜索的内容.为目标结构体的数组的起始位置.结构体第一个元素必须是序号,uint16类型
 * @param: size 结构体总数
 * @param: len 每个结构体的长度
 * @param: id 目标序号
 * 
 * @返回: 
 * @return: uint16  
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 ADVMidWaySearch(const uint8* pdata, uint16 size, uint16 len, uint16 id)
{
    uint16 mid, min, max, cmp, sml;
    min = 0;							//起始最小值
    max = size - 1;						//起始最大值

    if(len == 0)
    {
        return 0xFFFF;
    }

    while(1)							//循环查找
    {
        mid = (min + max) >> 1;			//取中值

        cmp = pdata[mid * len] + (pdata[mid * len + 1] << 8);
		
        if (id == cmp)					//判断是否已经找到
        {
            break;						//是的话退出
        }
        else if (id > cmp) 				//找到的数据是否比要找的小
        {
            if(mid == max)				//判断是否已经找完
            {
                                        //获取同类项以及属性
                sml = pdata[mid * len + 2] + (pdata[mid * len + 3] << 8);
            							//对比同类项是否有找到
            	if(id > cmp + (sml & 0xFFF) || !(sml & 0x8000))
            	{
                	mid = 0xffff;		//找不到
                }
                break;
            }
            min = mid + 1;				//最小值为当前值后一个
        }
        else                            //找到的数据比要找的大                        		
        {        	
            if(mid == min)              //判断是否已经查完
            {
                if(mid == 0)
                {
                    return 0xFFFF;
                }
            	mid --;					//看前一个数据的同类项

                cmp = pdata[mid * len] + (pdata[mid * len + 1] << 8);
                sml = pdata[mid * len + 2] + (pdata[mid * len + 3] << 8);
            							
            	if(id > cmp + (sml & 0xFFF) || !(sml & 0x8000))
            	{
                	mid = 0xffff;       //没有找到
                }
                break;
            }
            max = mid - 1;				//最大值为当前值前一个
        }
    }
    return mid;							//返回最终结果
}



/************************************************************************
 * @function: CopyBufferToStr
 * @描述: 将缓存里面的内容拷贝到结构体中
 * 
 * @参数: 
 * @param: sb 结构体描述信息
 * @param: buffer 缓存
 * @param: num 数量
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void CopyBufferToStr(const StrBuffer* sb, uint8* buffer, uint16 num)
{
    uint16 len = 0;

    for(uint16 i = 0; i < num; i++, sb++)
    {
        MoveBuffer(buffer + len, sb->addr, sb->len);
        len += sb->len;
    }
}


/************************************************************************
 * @function: CopyStrToBuffer
 * @描述: 将结构体里面的内容拷贝到缓存里面
 * 
 * @参数: 
 * @param: sb 结构体描述信息
 * @param: buffer 缓存
 * @param: num 数量
 * @返回: 
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void CopyStrToBuffer(const StrBuffer* sb, uint8* buffer, uint16 num)
{
    uint16 len = 0;

    for(uint16 i = 0; i < num; i++, sb++)
    {
        MoveBuffer(sb->addr, buffer + len, sb->len);
        len += sb->len;
    }
}




/************************************************************************
 * @function: CopyBufferToStrOffset
 * @描述: 将缓存里面的内容拷贝到结构体中
 * 
 * @参数: 
 * @param: sb 结构体描述信息
 * @param: str 结构体地址
 * @param: buffer 缓存
 * @param: num 数量
 * 
 * @返回: 
 * @return: uint16  操作的缓冲区的长度
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 CopyBufferToStrOffset(const StrBufOffset* sb, void* str, uint8* buffer, uint16 num)
{
    uint16 len = 0;
    uint8* strp = (uint8*)str;
    for(uint16 i = 0; i < num; i++, sb++)
    {
        MoveBuffer(buffer + len, strp + sb->offset, sb->len);
        len += sb->len;
    }
    return len;
}


/************************************************************************
 * @function: CopyStrToBufferOffset
 * @描述: 将结构体里面的内容拷贝到缓存里面
 * 
 * @参数: 
 * @param: sb 结构体描述信息
 * @param: str 结构体地址
 * @param: buffer 缓存
 * @param: num 数量
 * 
 * @返回: 
 * @return: uint16  操作的缓冲区长度
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 CopyStrToBufferOffset(const StrBufOffset* sb, void* str, uint8* buffer, uint16 num)
{
    uint16 len = 0;
    uint8* strp = (uint8*)str;
    for(uint16 i = 0; i < num; i++, sb++)
    {
        MoveBuffer(strp + sb->offset, buffer + len, sb->len);
        len += sb->len;
    }
    return len;
}




/************************************************************************
 * @function: FloatToFixPoint
 * @描述: 32位浮点数转换成定点数
 * 
 * @参数: 
 * @param: f 浮点数开始的缓存
 * @param: nf 转换好的小数位数 
 * 
 * @返回: 
 * @return: uint32  操作的缓冲区长度
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint32 FloatToFixPoint(uint8* f, uint8 nf)
{
    uint8 s = 0;
    if(f[3] & 0x80)               //符号位
    {
        s = 1;
    } 
                                        //指数位
    uint32 e = ((f[3] & 0x7F) << 1) + (f[2] >> 7);
                                        //数据内容
    uint64 v = ByteToInt24(f) | 0x800000;

    if(e >= 127)                        //左偏
    {
        e -= 127;                       //左偏指数
        v <<= e;                        //往左移位
        v *= guls_Do10Value[nf];        //保留的小数位数  
        v >>= 23;                       //去除多余的位数 
    }
    else
    {
        e = 127 - e;                    //右偏
        v *= guls_Do10Value[nf];        //定点化处理
        v >>= (23 + e);                 //去除多余的位数
    }

    e = v;
    if(s == 1)
    {
        //负数取反加1
        e = (~e) + 1; 
    }
    return e;
}



/************************************************************************
 *按3字节,30比特位超时来计算.
 ************************************************************************/
typedef struct
{
    uint32 baudrate;
    uint16 rotms;
}S_UartRotMs;

const S_UartRotMs gss_UartRotMs[] = 
{
    {600,       50},           //50ms
    {1200,      25},           //25ms
    {2400,      13},           //12.5ms
    {4800,      7},            //6.25ms
    {9600,      5},            //3.125ms
    {19200,     4},            //1.5625ms
    {38400,     3},            //0.78ms
    {115200,    2},            //0.26ms,试验证明,若设为1ms会出现接收一半就超时
    {0xFFFFFFFF,2},
};


/************************************************************************
 * @function: CalcUartRecvTimeOut
 * @描述: 根据串口波特率计算串口接收超时的延时时间
 * 
 * @参数: 
 * @param: baudrate 波特率
 * @param: 
 * 
 * @返回: 
 * @return: uint16 超时时间,单位ms
 * @说明: 
 * @作者: yzy (2013/6/6)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint16 CalcUartRecvTimeOut(uint32 baudrate)
{
    const S_UartRotMs* str;
    
    for(uint8 uc_i = 0; uc_i < sizeof(gss_UartRotMs) / sizeof(S_UartRotMs); uc_i++)
    {
        str = &gss_UartRotMs[uc_i];
        if(baudrate <= str->baudrate)
        {
            break;
        }
    }
    return str->rotms;
}


