/****************************************Copyright (c)**************************************************
**                                  ____科技有限公司
**                                          开发部
**
**
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名: farp.c
**创   建   人: yzy
**最后修改日期: 2017年9月1日
**描        述: 主通道处理函数
**注        意:
**--------------历史版本信息----------------------------------------------------------------------------
** 创建人: yzy
** 版  本: v1.0
*******************************************************************************/

#define EXT_FARP

#include <k_api.h>
#include <stdio.h>
#include <stdlib.h>
#include "public.h"
#include "main.h"
#include "atmodem.h"
#include "farp.h"




/******************************************************************************
**数据通讯状态断线重连安全时间数器
******************************************************************************/
uint16 gui_FarpWmSafeCnt;                   //数据通讯状态断线重连安全时间倒计时(秒)
uint16 gui_FarpSerSafeCnt;                   //数据通讯状态断线重连安全时间倒计时(秒)



/******************************************************************************
**重连间隔倒计时
******************************************************************************/
uint16 gui_FarpWmRcSec;                     //GPRS通路重连间隔计数器(秒倒计时)
uint16 gui_FarpSerRcSec;                     //GPRS Tcp Server通路重连间隔计数器(秒倒计时)


/******************************************************************************
**连续重连失败次数
******************************************************************************/
uint8 guc_FarpWmRcFailCnt;                  //GPRS连续重连失败次数
uint8 guc_FarpSerRcFailCnt;                 //Tcp Server连续重连失败次数


/******************************************************************************
**重连次数
******************************************************************************/
uint8 guc_FarpWmRcCnt;                      //联网失败后的重连次数(yzy:可在发起联网前赋值)
uint8 guc_FarpSerRcCnt;                     //联网失败后的重连次数(yzy:可在发起联网前赋值)



/******************************************************************************
**心跳周期计数器
******************************************************************************/
uint16 gui_FarpWmHBCYCnt;                   //心跳周期计数器


uint8 guc_FarpWmHKUnRpyCnt;                 //心跳无回复次数计数器




/******************************************************************************
**其它计数器
******************************************************************************/
uint16 gui_FarpHdRstCnt;                    //无线猫初始化花费时间计数器(如未插卡时会出现初始化失败)
uint8 guc_FarpPstTryCnt;                    //GPRS通路被动激活重拨次数计数器
uint8 guc_FarpNVHours;                      //无数据通讯小时数
uint8 guc_FastWmSttReqCnt;                  //MD 操作步骤延时

uint16 gui_FarpServerNoDataCnt;             //TCP Server  在侦听的情况下，无数据计数
uint16 gui_FarpFromClnNoDataCnt;             //TCP Server  与客户端1链接的情况下，无数据计数
uint8  guc_FarpFromClnCloseCnt;             //TCP Server  与客户端1链接的情况下, 主动关闭客户端次数

uint8  guc_FarpReActiveFlag;                //被动激活模式，采集器重启后，需要先与主站建立链接



uint16 gui_smseq;

cpu_stack_t  gs_TKFarpStack[TASK_FARP_STKL];
ktask_t      gs_TKFarpHandle;
kbuf_queue_t gs_TKFarpQueue;
char         gc_TKFarpQbuf[MSG_BUFF_LEN];
static char         g_TKFarpQ_buf_recv[2];
static size_t       g_TKFarpQ_recv_size;
ksem_t gs_FarpProc;   

/************************************************************************
 * @function: Farp_SendSMS
 * @描述: 远程通道发送短消息
 * 
 * @参数: 
 * @param: buffer 待发送的短信内容缓存.
 * @param: len 待发送的短信内容长度
 * @param: format 发送的短信格式
 * @param: type 目标短信号码类别,
 *                  0: 从哪里来到哪里去
 *                  1: 短信数据中心(默认)
 *                  2. 短信维护中心
 * 
 * @返回: 
 * @return: uint8  
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 Farp_SendSMS(uint8* buffer, uint16 len, uint8 format, uint8 type)
{
    uint8* dest;                            //目标短信号码指针

    switch(type)                            //根据目标短信号码类别指定指针
    {
        case 0:                             //哪里来哪里去
            dest = guc_RecvSmgNo;
            break;
        case 1:                             //短信数据中心
            dest = gs_FarpVar.smdc;
            break;
        case 2:                             //短信服务中心
            dest = gs_FarpVar.smfc;
            break;
        default:                            //其他类别, 参数错误
            return SYS_ERR_VAR;
    }
    //yzy 国网规约短信传输接口分拆方法
    //此发送函数执行后将改变发送缓存内容
    uint8 err;                              //连续发送失败次数
    uint8 flen;                             //单条短信内容长度
    uint8 smlseq;
    uint8 smfin;
    uint8 smsno[17];
    MoveBuffer(buffer, buffer + 2, len);
    IntToByte(buffer, (gui_smseq & 0x0FFF));
    //yzy 国网规约短信传输接口分拆方法
    
    if(SYS_MODM_Status().bit.regtt) //当前短信通道可用状态下发送短信
    {
        err = 0;
        smlseq = 0;
        while((len > 0) && (err < 2))
        {
            if(len > 135)                   //判断拆分后单条短信的长度和位置
            {
                flen = 135;
                smfin = 0;
            }
            else
            {
                flen = len;
                smfin = 1;
            }
                                            //拆分帧前缀
            buffer[1] &= 0x0F;
            buffer[1] |= ((smlseq & 0x07) << 4);
            if(smfin)
            {
                buffer[1] |= 0x80;
            }
                                            //重新载入目标号码
            MoveBuffer(dest, smsno, 17);
                                            //发送短信至目标号码
            if(!SYS_MODM_SendSMS(buffer, 2 + flen, (string)smsno, format))
            {                               //短信发送成功
//	                gs_GPIO.LED_BlinkSet(LED_FAR_T, 0, 0, 0);
                smlseq++;
                len -= flen;
                MoveBuffer(buffer + 2 + flen, buffer + 2, flen);
                err = 0;
            }
            else
            {
                err++;
            }
        }
        
        gui_smseq++;                        //无论是否发送成功,全局发送计数器增一
        if(len == 0)
        {
            SYS_OK();
        }
    }
    return SYS_ERR_FT;                       //短信发送失败
}


/************************************************************************
 * @function: Farp_SendIpData
 * @描述: 远程通道发送GPRS的IP数据
 * 
 * @参数: 
 * @param: buffer 发送缓存
 * @param: len 发送的长度
 * 
 * @返回: 
 * @return: uint8  
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 Farp_SendIpData(uint8* buffer, uint16 len)
{
                                            //IP数据在通道可用的情况下发送
    if(SYS_MODM_Status().bit.tcpcc |  SYS_MODM_Status().bit.udpcc)
    {                                       //发送IP数据
        if(!SYS_MODM_SendIP(buffer, len))
        {
//	            gs_GPIO.LED_BlinkSet(LED_FAR_T, 0, 0, 0);
            SYS_OK();                        //发送成功
        }
    }
    return SYS_ERR_FT;                      //IP数据发生失败
}



/************************************************************************
 * @function: Farp_SendTcpServerData
 * @描述: 远程通道发送GPRS的IP数据
 * 
 * @参数: 
 * @param: buffer 发送缓存
 * @param: len 发送的长度
 * 
 * @返回: 
 * @return: uint8  
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
uint8 Farp_SendTcpServerData(uint8* buffer, uint16 len)
{
                                            //IP数据在通道可用的情况下发送
    if(SYS_MODM_Status().bit.gsstt && (SYS_MODM_Status().bit.gsclncc1 || SYS_MODM_Status().bit.gsclncc2))
    {                                       //发送IP数据
        if(!SYS_MODM_SendTcpServer(buffer, len))
        {
            //SYS_LED_BlinkSet(LED_FAR_T, 0, 0, 0);
            SYS_OK();                        //发送成功
        }
    }
    return SYS_ERR_FT;                      //IP数据发生失败
}


/************************************************************************
 * @function: Farp_SendLoginData
 * @描述: 远程通道发送登录帧
 * 
 * @参数: 
 * @param: ch 0:GPRS,1:ETH
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_SendLoginData(uint8 ch)
{
    //gs_FarpVar.ldlen = GD_BuildLinkFrm(1, gs_FarpVar.ld);
    if(gs_FarpVar.ldlen > 0)
    {
        if(ch == 0)
        {
            Farp_SendIpData(gs_FarpVar.ld, gs_FarpVar.ldlen);
        }
        else
        {
            //Farp_SendEthData(gs_FarpVar.ld, gs_FarpVar.ldlen);
        }
    }
}


/************************************************************************
 * @function: Farp_SendLoginOutData
 * @描述: 远程通道发送退出登录帧
 * 
 * @参数: 
 * @param: ch 0:GPRS,1:ETH
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_SendLoginOutData(uint8 ch)
{
    //gs_FarpVar.lodlen = GD_BuildLinkFrm(2, gs_FarpVar.lod);
    if(gs_FarpVar.lodlen > 0)
    {
        if(ch == 0)
        {
            Farp_SendIpData(gs_FarpVar.lod, gs_FarpVar.lodlen);
        }
        else
        {
            //Farp_SendEthData(gs_FarpVar.lod, gs_FarpVar.lodlen);
        }
    }
}


const uint8_t cmdUpBuf[]=
                   {0x68, 0x33, 0x19, 0x27, 0x03, 0x18, 0x20, 0x68, 0x85, 0x4C, 
                    0x00 ,0x18 ,0x03 ,0x27 ,0x20 ,0x11 ,0x22 ,0x12 ,0x01 ,0xAA ,
                    0x00 ,0x1D ,0x01 ,0x18 ,0x03 ,0x27 ,0x20 ,0x11 ,0x22 ,0x00 ,
                    0x00 ,0x00 ,0x00 ,0x00 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,
                    0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xA0 ,0x00 ,
                    0x96 ,0x40 ,0x08 ,0x07 ,0x64 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,
                    0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,
                    0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,
                    0xFF ,0xFF ,0x00 ,0xFF ,0xFF ,0x89 ,0x01 ,0x9C ,0x16 };

/************************************************************************
 * @function: Farp_SendTestData
 * @描述: 远程通道发送心跳帧
 * 
 * @参数: 
 * @param: ch 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_SendTestData(uint8 ch)
{
    //gs_FarpVar.hklen = GD_BuildLinkFrm(3, gs_FarpVar.hkd);
    //if(gs_FarpVar.hklen > 0)
    {
        if(ch == 0)
        {
            Farp_SendIpData((uint8 *)cmdUpBuf, sizeof(cmdUpBuf));
        }
        else
        {
            //Farp_SendEthData(gs_FarpVar.hkd, gs_FarpVar.hklen);
        }
    }
}



/************************************************************************
 * @function: Farp_PreInit
 * @描述: 远程参数初始化
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_PreInit(void)
{                                           //参数载入
    ClearBuffer((uint8*)&gs_FarpVar, sizeof(FarpVar));
    //LoadSystemParam(PARA_TYPE_FARP);

    gui_FarpWmRcSec = 10;                   //初始化完成10s后进行远程连接
    gui_FarpSerRcSec = 10;
    //gui_FarpEthRcSec = 10;
    
    guc_FarpWmHKUnRpyCnt = 0;               //心跳无回复次数计数器清零
    //guc_FarpEthHKUnRpyCnt = 0;
    
    gui_FarpWmSafeCnt = 0;
    gui_FarpSerSafeCnt = 0;
    //gui_FarpEthSafeCnt = 0;
    
    guc_FarpWmRcCnt = 0;                   //联网失败后重连次数清零
    guc_FarpSerRcCnt = 0;
    //guc_FarpEthRcCnt = 0;
    
    gui_FarpHdRstCnt = 0;                   //模块复位计数器清零
    guc_FarpNVHours = 0;                    //无IP数据时间清零
    guc_FarpPstTryCnt = 0;                   //被动激活模式重拨次数计数器清零
    
    gui_FarpBkTmCnt = 0;                    //被动激活无数据休眠计数器清零
    guc_FarpWmRcFailCnt = 0;
    //guc_FarpEthRcFailCnt = 0;
    
    gui_FarpServerNoDataCnt = 0;
    guc_FarpFromClnCloseCnt = 0;
    
    guc_FarpLoginConfirmErr = 0;
    gul_FarpLoginDeadTime = 0xFFFFFFFF;
    
    gs_FarpVar.wmsv = 0x88000000;

}

void Load_Para(void)
{
    gs_FarpVar.hbcy = 120;              //默认10min
//	    gs_FarpVar.dcip = 0xC0A80101;                   //主站首选ip地址
//	    gs_FarpVar.dcpt = 8080;                   //主站首选端口号
//	    gs_FarpVar.dcib = 0xC0A80101;                   //主站备用ip地址
//	    gs_FarpVar.dcpb = 8080;                   //主站备用端口号
    gs_FarpVar.dcip = 0xA421EC73;                   //主站首选ip地址
    gs_FarpVar.dcpt = 8013;                   //主站首选端口号
    gs_FarpVar.dcib = 0xA421EC73;                   //主站备用ip地址
    gs_FarpVar.dcpb = 8013;                   //主站备用端口号
//	    devPara.Ip[0]=115;
//	    devPara.Ip[1]=236;
//	    devPara.Ip[2]=33;
//	    devPara.Ip[3]=164;
//	    devPara.NetPort=8013;

    MoveBuffer("cmnet", gs_FarpVar.gapn, 6);

    gs_FarpVar.ntpc = 0;                 //连接方式(00:TCP_01:UDP)
    gs_PstPara.wkms = 1;       //模块工作模式
    gs_PstPara.fpms = 1;       //客户端 工作模式
    gs_PstPara.rdct = 3;              //(被动模式)重拨次数
    //MoveBuffer(buff + 5, gs_PstPara.wksd, 3);//(时段模式)在线时段
    //gs_FarpVar.clnen = 1;
    //gs_FarpVar.seren = 0;

    Farp_SetWkmd();

    gs_FarpVar.rttm = 120;  //重连间隔(秒)
    //	gs_FarpVar.slep = buff[4] * 60;         //(被动模式)无数据通讯时间(秒)
    memset(gs_FarpVar.user,0,32);
    memset(gs_FarpVar.word,0,32);

    MoveBuffer("user", gs_FarpVar.user, strlen("user"));       //专网用户名
    MoveBuffer("pwd", gs_FarpVar.word, strlen("pwd"));  //专网密码



}

/************************************************************************
 * @function: Farp_InitProc
 * @描述: 远程进程初始化函数
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_InitProc(void)
{ 
    SYS_MODM_Reinit();                       //唤醒ATMODEM进程
    SYS_MODM_Init(&gs_TKFarpQueue);
    guc_FarpReActiveFlag = 1;
}



/************************************************************************
 * @function: Farp_WMSecondProc
 * @描述: 无线猫的秒处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_WMSecondProc(void)
{
    uint8 uc_closeclnflag = 0;
    uint8 uc_closeserflag = 0;
    /*
    if(gs_FarpVar.wmst & WMS_ETH0STT)
    {
        return;
    }
    */
                                            //yzy 2014-04-09,国网检测要求以太网优先,只要检测到网线即禁用GPRS.
    if(gs_FarpVar.wmst & WMS_EHSTT)
    {
        if((gs_FarpVar.wmst & WMS_STT_CLN) || (gs_FarpVar.wmst & WMS_STT_SER))
        {
//	            SYS_Message_Send(MSG_FARP_DISPPP, TASK_FARP_TKID);
            uint8 msg = MSG_FARP_DISPPP;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
            
        }
        gs_FarpVar.wmst &= ~WMS_CHALLSTT;
        return;
    }                                       //yzy 2014-04-09
                                            //获取模块状态
    TModemState modemstt = SYS_MODM_Status();

    if(gui_FarpWmSafeCnt > 0)               //数据通讯状态断线重连安全时间倒计时
    {
        gui_FarpWmSafeCnt--;
    }
    
    if(gui_FarpSerSafeCnt > 0)              //TCP Server 无数据通讯状态断线重连安全时间倒计时
    {
        gui_FarpSerSafeCnt--;
    }
    
    if(!(modemstt.bit.typeChecked))         //模块还未识别
    {
        return;
    }
    
    if(!(modemstt.bit.chnrdy))              //是否完成AT配置
    {
        if(++guc_FastWmSttReqCnt >= 5)      //每5秒钟
        {
            guc_FastWmSttReqCnt = 0;
            SYS_MODM_Step(Modem_Init);
        }
        return;
    }

    if(!(modemstt.bit.regtt))               //是否完成网络注册
    {
        gs_FarpVar.wmst &= ~WMS_CHALLSTT;
        gs_FarpVar.mcsq = 0;
                                            //及时更新模块状态
        if(++guc_FastWmSttReqCnt >= 15)     //每15秒钟
        {
            guc_FastWmSttReqCnt = 0;
            SYS_MODM_BeginCheck();
        }
        return;
    }

    gs_FarpVar.wmst |= WMS_STT_GSM;
    gs_FarpVar.mcsq = modemstt.bit.signl;
    
    
    if(!(modemstt.bit.pppoe))       //是否完成PPP链接
    {
        gs_FarpVar.wmst &= ~WMS_STT_PPP;    //数据通道不可用
        if(++guc_FastWmSttReqCnt >= 10)     //每10秒钟
        {
//	            SYS_Message_Send(MSG_FARP_CNTPPP, TASK_FARP_TKID);
            uint8 msg = MSG_FARP_CNTPPP;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
            
            guc_FastWmSttReqCnt = 0;
        }
        
//	        if(guc_FastWmSttReqCnt % 3 == 0)     //每3秒钟
//	        {
//	            SYS_MODM_BeginCheck();
//	        }
        return;
    }
    gs_FarpVar.wmst |= WMS_STT_PPP;
    
    
    
    if(gs_FarpVar.seren == 1)           //服务器模式处理
    {
        uint32 lisip[2];
        SYS_MODM_GetLinkInfo(lisip);     //查询接收的情况
      
        if(modemstt.bit.gsstt == 0)         //TCP Server 无客户端链接
        {
            gs_FarpVar.wmst &= ~(WMS_STT_SER | WMS_STT_SER_CNT1 | WMS_STT_SER_CNT2);    //数据通道不可用
            
            if(gui_FarpSerRcSec == 0)        //永久在线模式断线后即开始重试倒计时
            {
                gui_FarpSerRcSec = gs_FarpVar.rttm;
            }
            
            if(gui_FarpSerSafeCnt > 0)
            {
                gui_FarpSerSafeCnt = 0;
                gui_FarpSerRcSec = 1;
                
                guc_FarpSerRcCnt = 3;
            }
            
            if(gui_FarpSerRcSec > 0)
            {
                gui_FarpSerRcSec--;         //计数器递减
                if(gui_FarpSerRcSec == 0)   //重试间隔已到,进行重连
                {
//	                    SYS_Message_Send(MSG_FARP_CNTSERVER, TASK_FARP_TKID);
                    uint8 msg = MSG_FARP_CNTSERVER;
                    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                    
                }
            }
        }
        else
        {
            gs_FarpVar.wmst |= WMS_STT_SER;
            
            gui_FarpServerNoDataCnt++; 
            if((modemstt.bit.gsclncc1) && (modemstt.bit.gsclncc2))    //链接链接都连上了，踢掉原来的
            {
                if(gs_FarpVar.lisflg[0])
                {
//	                    SYS_Message_Send(MSG_FARP_DISFROMCLN1, TASK_FARP_TKID);
                    uint8 msg = MSG_FARP_DISFROMCLN1;
                    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                    
                }
                if(gs_FarpVar.lisflg[1])
                {
//	                    SYS_Message_Send(MSG_FARP_DISFROMCLN2, TASK_FARP_TKID);
                    uint8 msg = MSG_FARP_DISFROMCLN2;
                    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                    
                }
            }
            gs_FarpVar.lisflg[0] = modemstt.bit.gsclncc1;
            gs_FarpVar.lisflg[1] = modemstt.bit.gsclncc2;

            if(modemstt.bit.gsclncc1 == 1)  //收到的客户端1 
            {
                gs_FarpVar.wmst |= WMS_STT_SER_CNT1;
                gui_FarpServerNoDataCnt = 0;
                
                if(gui_FarpFromClnNoDataCnt > 0)   //
                {
                    gui_FarpFromClnNoDataCnt--;
                
                    if(gui_FarpFromClnNoDataCnt == 0)    //在线多久后无数据则，主动下线
                    {
//	                        SYS_Message_Send(MSG_FARP_DISFROMCLN1, TASK_FARP_TKID);
                        uint8 msg = MSG_FARP_DISFROMCLN1;
                        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                        
                        guc_FarpFromClnCloseCnt++;
                    }
                }
            }
            else
            {
                gs_FarpVar.wmst &= ~WMS_STT_SER_CNT1;
            }
            
            if(modemstt.bit.gsclncc2 == 1)  //收到的客户端2 
            {
                gs_FarpVar.wmst |= WMS_STT_SER_CNT2;
                gui_FarpServerNoDataCnt = 0;
                
                if(gui_FarpFromClnNoDataCnt > 0)   //
                {
                    gui_FarpFromClnNoDataCnt--;
                
                    if(gui_FarpFromClnNoDataCnt == 0)    //在线多久后无数据则，主动下线
                    {
//	                        SYS_Message_Send(MSG_FARP_DISFROMCLN2, TASK_FARP_TKID);
                        uint8 msg = MSG_FARP_DISFROMCLN2;
                        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                        
                        guc_FarpFromClnCloseCnt++;
                    }
                }
            }
            else
            {
                gs_FarpVar.wmst &= ~WMS_STT_SER_CNT2;
            }
            
            gui_FarpSerRcSec = 0;
            
            if((guc_FarpFromClnCloseCnt > 3) || gui_FarpServerNoDataCnt > 7200ul)   //连续3次关闭客户端，均无数据响应，则重启侦听
            {
                guc_FarpFromClnCloseCnt = 0;
                gui_FarpServerNoDataCnt = 0;
//	                SYS_Message_Send(MSG_FARP_DISSERVER, TASK_FARP_TKID);
                uint8 msg = MSG_FARP_DISSERVER;
                krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                
                uc_closeserflag = 1;
            }
        }
    }

    if(gs_FarpVar.clnen == 1)           //客户端模式
    {
        if((modemstt.bit.tcpcc == 0) && (modemstt.bit.udpcc == 0))    //TCP 不在线
        {
            gs_FarpVar.wmst &= ~WMS_STT_CLN;    //数据通道不可用
            if(gs_FarpVar.wkmd == 0x00)         //实时在线模式
            {
                if(gui_FarpWmRcSec == 0)        //永久在线模式断线后即开始重试倒计时
                {
                    gui_FarpWmRcSec = gs_FarpVar.rttm;
                }
                                                //数据通讯状态下掉线马上重连
                if(gui_FarpWmSafeCnt > 0)
                {
                    gui_FarpWmSafeCnt = 0;
                    
                    gui_FarpWmRcSec = 1;
                    guc_FarpWmRcCnt = 3;       //通讯状态下断线重连3次
                }
                if(gui_FarpWmRcSec > 0)
                {
                    gui_FarpWmRcSec--;         //计数器递减
                    if(gui_FarpWmRcSec == 0)   //重试间隔已到,进行重连
                    {
//	                        SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
                        uint8 msg = MSG_FARP_CNTGPRS;
                        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                        
                    }
                }
            }
            else if(gs_FarpVar.wkmd == 0x01)    //被动激活模式
            {
                //
            }
        }
        else
        {
            gs_FarpVar.wmst |= WMS_STT_CLN;     //数据通道可用
            
            if(guc_FarpLoginConfirmErr)           //登录后n秒内未收到确认帧,执行重连操作
            {
                if(gul_SysRunSecs > gul_FarpLoginDeadTime)
                {
//	                    SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
                    uint8 msg = MSG_FARP_DISGPRS;
                    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                    
                    uc_closeclnflag = 1;
                    gul_FarpLoginDeadTime = 0xFFFFFFFF;
                }
            }
            
            if(gui_FarpWmHBCYCnt > 0)
            {
                gui_FarpWmHBCYCnt--;
                if(gui_FarpWmHBCYCnt == 0)      //心跳周期到发心跳帧
                {
                    if(guc_FarpWmHKUnRpyCnt >= 3) //心跳无回复次数超过3次
                    {
//	                        SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
                        uint8 msg = MSG_FARP_DISGPRS;
                        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                        
                        uc_closeclnflag = 1;
                        guc_FarpWmHKUnRpyCnt = 0; //心跳无回复次数清零
                    }
                    else
                    {
                        //Farp_SendHKData(0);      //发送心跳数据
                        Farp_SendTestData(0);
                        guc_FarpWmHKUnRpyCnt++;
                        gui_FarpWmHBCYCnt = gs_FarpVar.hbcy;
                    }
                }
            }
            else
            {
                gui_FarpWmHBCYCnt = gs_FarpVar.hbcy;
            }
            gui_FarpWmRcSec = 0;                //重试次数清零
                                                // 
            if(gs_FarpVar.wkmd == 0)            //实时在线模式
            {
                //....
            }
            else if(gs_FarpVar.wkmd == 1)       //被动激活模式
            {
                gui_FarpBkTmCnt++;              //无数据休眠计数器累加
                                                //无数据通讯时间超过定值或需要断开连接
                if(gui_FarpBkTmCnt >= gs_FarpVar.slep)
                {                               //置断开连接消息
//	                    SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
                    uint8 msg = MSG_FARP_DISGPRS;
                    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                    
                    uc_closeclnflag = 1;
                }
            }
            else                                //短信模式直接断开连接
            {
//	                SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
                
                uint8 msg = MSG_FARP_DISGPRS;
                krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                uc_closeclnflag = 1;
            }
        }
    }
    
    if((modemstt.bit.gsstt == 0)  && (uc_closeclnflag == 1))     //重启客户端时，发现服务器侦听也失败的，  则先重启PPP
    {
//	        SYS_Message_Send(MSG_FARP_DISPPP, TASK_FARP_TKID);                 
//	        SYS_Message_Send(MSG_FARP_CNTPPP, TASK_FARP_TKID);    
        uint8 msg = MSG_FARP_DISPPP;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        msg = MSG_FARP_CNTPPP;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
    }
    if(uc_closeserflag == 1)
    {
//	        SYS_Message_Send(MSG_FARP_CNTSERVER, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_CNTSERVER;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
    }
    if((uc_closeclnflag == 1) && (gs_FarpVar.wkmd == 0))
    {
//	        SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_CNTGPRS;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
    }
}






/************************************************************************
 * @function: Farp_SecondProc
 * @描述: 远程通道秒事件处理函数
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_SecondProc(void)
{
    sem_count_t t;
    krhino_sem_count_get(&gs_FarpProc,&t);

    if(t <= 0)
    {
        return;
    }

    Farp_WMSecondProc();
    
    gs_FarpVar.modemip = SYS_MODM_GetIP();   //获取本地IP
  
                                            //点灯服务
    if(gs_FarpVar.wmst & (WMS_STT_CLN | WMS_ETH0STT))
    {
//	         SYS_LED_BlinkSet(LED_GPRS, 2, 0, 0);//亮灯
    }
    else
    {
//	         SYS_LED_BlinkSet(LED_GPRS, 0xFF, 0, 0);
    }
                                            //初始化异常纠正机制
    if((!SYS_MODM_Status().bit.regtt) )
    {
        gui_FarpHdRstCnt++;                 //计数器累加
    
        if(gui_FarpHdRstCnt >= 120)         //超过两分钟还未完成初始化,复位设备
        {
            gui_FarpHdRstCnt = 0;           //复位计数器清零
            SYS_MODM_Reset(1);               //复位设备
        }
    }
    else
    {
        gui_FarpHdRstCnt = 0;               //初始化完成,清计数器
    }
    
    if(guc_FarpReActiveFlag && gs_FarpVar.clnen)    //被动激活模式，采集器重启后，需要先与主站建立链接
    {
        if((gs_FarpVar.wmst & WMS_STT_GSM) && (gs_FarpVar.wmst & WMS_STT_PPP)) 
        {
            guc_FarpReActiveFlag = 0;
//	            SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
            uint8 msg = MSG_FARP_CNTGPRS;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
            
        }
        
    }

}



/************************************************************************
 * @function: Farp_MinProc
 * @描述: 分处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_MinProc(void)
{
    SYS_MODM_BeginCheck();                   //更新无线模块状态字
    
    //--------------------------------------------------------------------
    
    if(gs_PstPara.fpms == 3)                //时段在线模式
    {                                       //实时更新工作状态
        void Farp_SetWkmd(void);
        Farp_SetWkmd();
    }
    
}





/************************************************************************
 * @function: Farp_HourProc
 * @描述: 小时处理函数
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_HourProc(void)
{
    guc_FarpNVHours++;                      //无数据通讯小时数增加

    if(guc_FarpNVHours >= 16)               //连续三天无数据通讯复位ARM系统
    {
        sleep_ms(30000);                  //等待30s,以使系统能够将重要数据保存完毕
        guc_FarpNVHours = 0;
                                            //复位系统
        //gs_OS.Message_Send(MSG_MAIN_RESET, TASK_MAIN_TKID);
    }
}


/************************************************************************
 * @function: Farp_DayProc
 * @描述: 天处理函数
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_DayProc(void)
{
//	    SYS_Message_Send(MSG_FARP_VAR, TASK_FARP_TKID);
}

#if (Modem_M72X_SMS_EN > 0)
/************************************************************************
 * @function: Farp_SmgReadProc
 * @描述: 读取短消息
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_SmgReadProc(void)
{
    uint8 uc_data[256];                     //临时缓存
    uint8 format;
    uint8 uc_len = 0;

    uc_len = SYS_MODM_ReadSMS(uc_data, guc_RecvSmgNo, &format);

    _IF_TRUE_RETURN_VOID(uc_len == 0);

//	    SYS_LED_BlinkSet(LED_FAR_R, 0, 0, 0);
                                            //转移目标号码
    MoveBuffer(guc_RecvSmgNo, gs_FarpVar.smfc, 17);
                                            //短信数据帧被动处理
//	    PstFrmProc(PST_CHN_SMS, uc_data, uc_len, uc_data, uc_len);

}
#endif



/************************************************************************
 * @function: Farp_IpDataReadProc
 * @描述: 读取IP数据并处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_IpDataReadProc(void)
{
    uint8 uc_data[LEN_OF_IPRECV];                    //临时缓存
    uint16 length;
    uint16 ui_len;
                                            //循环读取IP数据(超长帧需要读取多次)
    length = 0;
    for(uint8 uc_i = 0; uc_i < 10; uc_i++)
    {                                       //单次读取数据
        ui_len = SYS_MODM_ReadIP(uc_data + length, sizeof(uc_data) - length);
        length += ui_len;
                                            //读到数据,当数据长度过小,可以认为是超长帧接收结束.
        if((ui_len > 0) && (ui_len < 900))
        {
            break;
        }
                                            //超出缓存,退出.
        if(length >= sizeof(uc_data))
        {
            break;
        }
        sleep_ms(200); 
    }

    _IF_TRUE_RETURN_VOID(length == 0);      //读出的数据长度为0则返回不处理

//	    SYS_LED_BlinkSet(LED_FAR_R, 0, 0, 0);
    
    LOG_DUMPHEX(LOG_LEVEL_DEBUG, "tcp recv:\n", uc_data, length);
    PstFrmProc(PST_CHN_TCP, uc_data, length, uc_data, length);  //数据帧的被动处理

    guc_FarpWmHKUnRpyCnt = 0;               //收到IP数据,清心跳无回复次数计数器
    guc_FarpNVHours = 0;                    //无IP数据时间清零
}


/************************************************************************
 * @function: Farp_FromClientDataReadProc
 * @描述: 收到服务器的客户端1通道的数据
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2015.03.26)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_FromClientDataReadProc(void)
{
    uint8 uc_data[256];                    //临时缓存
    uint16 length;
    uint16 ui_len;
                                            //循环读取IP数据(超长帧需要读取多次)
    length = 0;
    for(uint8 uc_i = 0; uc_i < 10; uc_i++)
    {                                       //单次读取数据
        ui_len = SYS_MODM_ReadServer(0, uc_data + length, sizeof(uc_data) - length);
        length += ui_len;
                                            //读到数据,当数据长度过小,可以认为是超长帧接收结束.
        if((ui_len > 0) && (ui_len < 900))
        {
            break;
        }
                                            //超出缓存,退出.
        if(length >= sizeof(uc_data))
        {
            break;
        }
        sleep_ms(200); 
    }

    _IF_TRUE_RETURN_VOID(length == 0);      //读出的数据长度为0则返回不处理

//	    SYS_LED_BlinkSet(LED_FAR_R, 0, 0, 0);
    
//	    PstFrmProc(PST_CHN_SER, uc_data, length, uc_data, length);  //数据帧的被动处理

    guc_FarpNVHours = 0;                    //无IP数据时间清零
}


/************************************************************************
 * @function: Farp_UpDataActiveIP
 * @描述: 被动激活模式下，主动上送数据，之前先建立客户端
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2015/03/27)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_UpDataActiveIP(void)
{
    if(gs_FarpVar.clnen == 1)           //客户端模式
    {
        if((DevModem->stt.bit.tcpcc == 0) && (DevModem->stt.bit.udpcc == 0)) 
        {             
//	            SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);   //置连接GPRS消息
            uint8 msg = MSG_FARP_CNTGPRS;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        }
    }
    
    guc_FarpPstTryCnt = 0;                   //被动模式重试次数清零.
}


/************************************************************************
 * @function: Farp_RingProc
 * @描述: 振铃信号处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_RingProc(void)
{
                                            //置连接GPRS消息
    uint8 msg = MSG_FARP_CNTGPRS;
    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
                                            
//	    SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
    guc_FarpPstTryCnt = 0;                   //被动模式重试次数清零.
}


/************************************************************************
 * @function: Farp_Close_PPP
 * @描述: 注销PPP处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2015/03/23)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_Close_PPP(void)
{
    SYS_MODM_ClosePPP();                     //断开PPP连接
    
    gs_FarpVar.wmst &= ~WMS_STT_PPP;        //清零状态字
    gs_FarpVar.wmst &= ~WMS_STT_CLN;        //清零状态字
    gs_FarpVar.wmst &= ~WMS_STT_SER;        //清零状态字
    gs_FarpVar.wmst &= ~WMS_STT_SER_CNT1;
    gs_FarpVar.wmst &= ~WMS_STT_SER_CNT2;
}


/************************************************************************
 * @function: Farp_Creat_PPP
 * @描述: 连接PPP处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2015/03/23)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_Creat_PPP(void)
{
    if(!(gs_FarpVar.wmst & WMS_STT_GSM))      //
    {
        return;
    }
    if((gs_FarpVar.wmst & WMS_STT_PPP))
    {
        SYS_MODM_ClosePPP();                 //先关闭PPP连接
    }
    
    for(uint8 uc_i = 0; uc_i < 3; uc_i++)
    {
        sleep_ms(1000);
        if(!SYS_MODM_CreatePPP(
                (string)gs_FarpVar.gapn, 
                (string)gs_FarpVar.user, 
                (string)gs_FarpVar.word
                ))      
        {                                   
            gs_FarpVar.wmst |= WMS_STT_PPP;
            return;                     //建立成功直接退出
        }
    }
    SYS_MODM_ClosePPP();                 //TCP连接不成功,关闭PPP连接
}


/************************************************************************
 * @function: Farp_WM_Connect
 * @描述: 连接GPRS处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_WM_Connect(void)
{
    uint8 uc_i;                             //循环变量
    
    if(!(gs_FarpVar.wmst & WMS_STT_GSM) || !(gs_FarpVar.wmst & WMS_STT_PPP))      //
    {
        return;
    }
    
    if(!gs_FarpVar.clnen)   //客户端模式开启
    {
        return;
    }
    
    if((gs_FarpVar.wmst & WMS_STT_CLN))       //当前数据通道是否已经可用
    {                                       //置断开连接消息
//	        SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_DISGPRS;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
        gui_FarpWmRcSec = 1;                //断开连接后马上重连        
        guc_FarpPstTryCnt = 0;               //被动模式重连次数清零
        return;
    }

    if(gs_FarpVar.wkmd == 1)                //被动激活模式
    {                                       //重连次数超过最大次数则不进行重连
        if(guc_FarpPstTryCnt > gs_FarpVar.rtct)
        {
            return;
        }
        guc_FarpPstTryCnt++;                 //否则重连次数累加
    }

    guc_FarpWmRcFailCnt++;                  //重连失败次数累加
    if(guc_FarpWmRcFailCnt > 5)             //保护机制:连续5次重连失败,复位模块
    {
        SYS_MODM_Reset(1);                   //复位设备
        guc_FarpWmRcFailCnt = 0;
    }
    
    gui_FarpWmRcSec = 0;                    //重试间隔计数器清零

    for(uc_i = 0; uc_i < gs_FarpVar.rdct; uc_i++)
    {                                       //两次重试之间短暂延时
        sleep_ms(1000);
        
        if(!(gs_FarpVar.wmst & WMS_STT_CLN))
        {
                                                //连接首选主站
            if(!(guc_FarpLoginConfirmErr & 0x01))   //上次主用登陆确认无异常
            {
                if(!SYS_MODM_CreateIP(gs_FarpVar.ntpc, gs_FarpVar.dcip, gs_FarpVar.dcpt))
                {
                    guc_FarpLoginConfirmErr = 0;
                    gul_FarpLoginDeadTime = gul_SysRunSecs + 10;
                                                    //
                    gs_FarpVar.wmst |= WMS_STT_CLN;
                    guc_FarpPstTryCnt = 0;          //被动模式重连次数清零
                    Farp_SendLoginData(0);          //发送登录帧
                    //Farp_SendHKData(0);             //发送心跳帧
                                                    //初始化心跳周期
                    gui_FarpWmHBCYCnt = gs_FarpVar.hbcy;
                                                    //实时在线模式无有效数据计数器初始化
                    gui_FarpWmSafeCnt = gs_FarpVar.hbcy;
                    guc_FarpWmRcFailCnt = 0;        //重连失败次数清零
                    
                    SYS_MODM_Step(Modem_IPState);
                    return;
                }
            }
                                                    //连接备用主站
            if(!(guc_FarpLoginConfirmErr & 0x02))   //上次备用登陆确认无异常
            {
                if(!SYS_MODM_CreateIP(gs_FarpVar.ntpc, gs_FarpVar.dcib, gs_FarpVar.dcpb))
                {
                    guc_FarpLoginConfirmErr = 0;
                    gul_FarpLoginDeadTime = gul_SysRunSecs + 10;
                                                    //
                    gs_FarpVar.wmst |= WMS_STT_CLN;
                    guc_FarpPstTryCnt = 0;          //被动模式重连次数清零
                    Farp_SendLoginData(0);          //发送登录帧
                    //Farp_SendHKData(0);             //发送心跳帧
                                                    //初始化心跳周期
                    gui_FarpWmHBCYCnt = gs_FarpVar.hbcy;
                    gui_FarpWmSafeCnt = gs_FarpVar.hbcy;
                    guc_FarpWmRcFailCnt = 0;        //重连失败次数清零
                    
                    SYS_MODM_Step(Modem_IPState);
                    return;
                }
            }
            guc_FarpLoginConfirmErr = 0;
        }
        if((!(gs_FarpVar.wmst & WMS_STT_CLN)) && (!(gs_FarpVar.wmst & WMS_STT_SER)))
        {
//	            SYS_Message_Send(MSG_FARP_DISPPP, TASK_FARP_TKID);                 //TCP连接不成功,关闭PPP连接
            uint8 msg = MSG_FARP_DISPPP;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
            
        }
    }
                                            //理论上此处不需要discnt
                                            //但是使用过程中发现某些模块CreateIP不成功后也需要DiscntIP
//	    SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
                                            
//	    SYS_Message_Send(MSG_FARPE_FCNT, TASK_FARP_TKID);
    uint8 msg = MSG_FARP_DISGPRS;
    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
    msg = MSG_FARPE_FCNT;//连接失败处理
    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);                                            
    if(guc_FarpWmRcCnt > 0)                //通讯状态下断线重连失败后5秒后重连
    {
        guc_FarpWmRcCnt--;
        gui_FarpWmRcSec = 10;
    }
}


/************************************************************************
 * @function: Farp_Creat_Server
 * @描述: 建立TCP服务端
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_Creat_Server(void)
{
    uint8 uc_i;                             //循环变量
    
    if(!(gs_FarpVar.wmst & WMS_STT_GSM) || !(gs_FarpVar.wmst & WMS_STT_PPP))      //
    {
        return;
    }
    
    if(!gs_FarpVar.seren)   //客户端模式开启
    {
        return;
    }
    
    if((gs_FarpVar.wmst & WMS_STT_SER))       //当前数据通道是否已经可用
    {                                       //置断开连接消息
//	        SYS_Message_Send(MSG_FARP_DISSERVER, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_DISSERVER;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
        gui_FarpSerRcSec = 1;                //断开连接后马上重连        
        return;
    }

    guc_FarpSerRcFailCnt++;                  //重连失败次数累加
    if(guc_FarpSerRcFailCnt > 5)             //保护机制:连续5次重连失败,复位模块
    {
        SYS_MODM_Reset(1);                   //复位设备
        guc_FarpSerRcFailCnt = 0;
    }
    
    gui_FarpSerRcSec = 0;                    //重试间隔计数器清零

    for(uc_i = 0; uc_i < gs_FarpVar.rdct; uc_i++)
    {                                       //两次重试之间短暂延时
        sleep_ms(1000);
        
        if(!(gs_FarpVar.wmst & WMS_STT_SER))
        {
            if(!SYS_MODM_CreatServer(0, gs_FarpVar.lispt))  //
            {
                gs_FarpVar.wmst |= WMS_STT_SER;
                gs_FarpVar.wmst &= ~WMS_STT_SER_CNT1;
                gs_FarpVar.wmst &= ~WMS_STT_SER_CNT2;
                
                gui_FarpFromClnNoDataCnt = gs_FarpVar.hbcy * 10;    //江苏规定为，10倍的心跳周期
                gui_FarpSerSafeCnt = gs_FarpVar.hbcy;
                guc_FarpSerRcFailCnt = 0;        //重连失败次数清零
                guc_FarpFromClnCloseCnt = 0;
                
                SYS_MODM_Step(Modem_IPState);
                return;
            }
        }
    }
    
    if((!(gs_FarpVar.wmst & WMS_STT_CLN)) && (!(gs_FarpVar.wmst & WMS_STT_SER)))
    {
//	        SYS_Message_Send(MSG_FARP_DISPPP, TASK_FARP_TKID);                 //TCP连接不成功,关闭PPP连接
        uint8 msg = MSG_FARP_DISPPP;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
    }
                                            //理论上此处不需要discnt
                                            //但是使用过程中发现某些模块CreateIP不成功后也需要DiscntIP
//	    SYS_Message_Send(MSG_FARP_DISSERVER, TASK_FARP_TKID);
//	                                            //连接失败处理
//	    SYS_Message_Send(MSG_FARPE_FCNT, TASK_FARP_TKID);
    uint8 msg = MSG_FARP_DISSERVER;
    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
    msg = MSG_FARPE_FCNT;
    krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
    if(guc_FarpSerRcCnt > 0)                //通讯状态下断线重连失败后5秒后重连
    {
        guc_FarpSerRcCnt--;
        gui_FarpSerRcSec = 10;
    }
}

/************************************************************************
 * @function: Farp_PrioConnect
 * @描述: 按照优先级选择通道进行连接
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_PrioConnect(void)
{
//	    if(gs_FarpVar.wmst & WMS_EHSTT)
//	    {
//	        SYS_Message_Send(MSG_FARP_CNTETH, TASK_FARP_TKID);
//	        uint8 msg = MSG_FARP_DISFROMCLN1;
//	        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
//	        
//	    }
//	    else
    {
//	        SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_CNTGPRS;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
    }
}





/************************************************************************
 * @function: Farp_Close_Server
 * @描述: 断开TCP Server 链接
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_Close_Server(void)
{
    SYS_MODM_CloseTcpServer();                     //断开TCP连接
                                            //断开连接成功
    gs_FarpVar.wmst &= ~WMS_STT_SER;        //清零状态字
    gs_FarpVar.wmst &= ~WMS_STT_SER_CNT1;
    gs_FarpVar.wmst &= ~WMS_STT_SER_CNT2;
}



/************************************************************************
 * @function: Farp_WM_DisCnt
 * @描述: 断开GPRS连接
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_WM_DisCnt(void)
{
    Farp_SendLoginOutData(0);                //发送退出登陆帧
    
    SYS_MODM_CloseIP();                     //断开TCP连接

    gs_FarpVar.wmst &= ~WMS_STT_CLN;        //清零状态字
    gui_FarpBkTmCnt = 0;                    //被动激活模式无数据通讯休眠时间计数器清零
}




/************************************************************************
 * @function: Farp_Close_From_Client1
 * @描述: 断开收到的客户端链接1
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_Close_From_Client1(void)
{
    SYS_MODM_CloseFromClient(0);                     //断开收到的客户端链接1

    gs_FarpVar.wmst &= ~WMS_STT_SER_CNT1;
}


/************************************************************************
 * @function: Farp_Close_From_Client2
 * @描述: 断开收到的客户端链接2
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_Close_From_Client2(void)
{
    SYS_MODM_CloseFromClient(1);                     //断开收到的客户端链接1

    gs_FarpVar.wmst &= ~WMS_STT_SER_CNT2;
}



/************************************************************************
 * @function: Farp_RecvValidIpProc
 * @描述: 远程通道收到有效Ip数据后的处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_RecvValidIpProc(void)
{
    gui_FarpBkTmCnt = 0;                    //无数据休眠计数器清零
    
    gui_FarpWmSafeCnt = gs_FarpVar.hbcy;    //将无有效数据计数器复位
    //gui_FarpEthSafeCnt = gs_FarpVar.hbcy;
    
    gui_FarpWmHBCYCnt = gs_FarpVar.hbcy;
//#if SG_INSPECT
//    gui_FarpEthHBCYCnt = 60;//默认1分钟
//#else
//    gui_FarpEthHBCYCnt = gs_FarpVar.hbcy;
//#endif    
}

       
       
       
/************************************************************************
 * @function: Farp_RecvValidTcpSerProc
 * @描述: 远程通道收到有效TcpServer数据后的处理
 * @参数: 
 * @返回: 
 * @说明: 
 * @作者: yzy (2014/1/14)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_RecvValidTcpSerProc(void)
{
    gui_FarpSerSafeCnt = gs_FarpVar.hbcy;
    gui_FarpFromClnNoDataCnt = gs_FarpVar.hbcy * 10;    //江苏规定为，10倍的心跳周期
    guc_FarpFromClnCloseCnt = 0;
}
       
/************************************************************************
**函数名称: void Farp_SetWkmd(void)
**描 述: 无线模块工作模式的设定
**
**输 入: 
**输 出: 
**
**备 注: 
**-----------------------------------------------------------------------
**作 者: yzy
**日 期: 09-09-15
*************************************************************************/
void Farp_SetWkmd(void)
{
  
    uint8 ucClnen = gs_FarpVar.clnen;
    uint8 ucSeren = gs_FarpVar.seren;
                                        //设定终端工作模式
    if(gs_PstPara.wkms == 1)            //客户端模式
    {
        gs_FarpVar.clnen = 1;
        gs_FarpVar.seren = 0;
    }
    else if(gs_PstPara.wkms == 2)       //服务器模式
    {
        gs_FarpVar.clnen = 0;
        gs_FarpVar.seren = 1;
    }
    else                        // 混合模式
    {
        gs_FarpVar.clnen = 1;
        gs_FarpVar.seren = 1;
        gs_PstPara.fpms = 2;    //混合模式下，客户端为被动激活
    }
    
    if(gs_FarpVar.seren)
    {
        if(ucSeren == 0)    //从 非TCP server 状态  到 激活TCP server 状态
        {
//	            SYS_Message_Send(MSG_FARP_CNTSERVER, TASK_FARP_TKID);
            uint8 msg = MSG_FARP_CNTSERVER;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
            
        }
    }
    
    if(gs_FarpVar.clnen)
    {
                                    //设定客户端工作模式
        uint8 mode = gs_FarpVar.wkmd;
        
                                            
        if(gs_PstPara.fpms == 2)                //被动激活模式
        {
            gs_FarpVar.wkmd = 1;
        }
        else if(gs_PstPara.fpms == 3)           //时段在线模式
        {
            if(STR_GetBits(gs_PstPara.wksd, 1, GetTime()->hour))
            {
                gs_FarpVar.wkmd = 0;
            }
            else
            {
                gs_FarpVar.wkmd = 1;
            }
        }
        else                                    //永久在线模式
        {
            gs_FarpVar.wkmd = 0;
        }
                                                //设定重拨重试次数
        if(gs_FarpVar.wkmd == 0)                //永久在线模式
        {
            gs_FarpVar.rdct = 2;
        }
        else if(gs_FarpVar.wkmd == 1)           //被动模式
        {
            gs_FarpVar.rdct = gs_PstPara.rdct;  //重拨次数
            if(gs_FarpVar.rdct == 0)            //被动激活模式至少重拨1次
            {
                gs_FarpVar.rdct = 1;
            }
            gs_FarpVar.rtct = 1;                //重试一次(每次按重拨次数连接)
        }
                                                //从被动切换到永久,需要重连
        if(((mode > gs_FarpVar.wkmd) && ((gs_FarpVar.wmst & WMS_STT_CLN) == 0)) || (ucClnen == 0))
        {
//	            SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
            uint8 msg = MSG_FARP_CNTGPRS;
            krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
            
        }
    }
}











/************************************************************************
**函数名称: void Farp_UpDateVar(void)
**描 述: 初始化远程通讯的参数
**
**输 入: 
**输 出: 
**
**备 注: 
**-----------------------------------------------------------------------
**作 者: chenyj 
**日 期: 
**-----------------------------------------------------------------------
**修 改: yzy 
**日 期: 
*************************************************************************/
void Farp_UpdateVar(void)
{
    //LoadSystemParam(PARA_TYPE_FARP);
}



/************************************************************************
 * @function: Farp_ParaChg
 * @描述: 重要连接参数更改,需要更新联网状态
 * 
 * @参数: 
 * @param: pdata 
 * @返回: 
 * @说明:
 * @作者: yzy (2011-2-24)
 *-----------------------------------------------------------------------
 * @修改人: 
 ************************************************************************/
void Farp_ParaChg(void)
{
    if(gs_FarpVar.wkmd == 0)            //实时在线模式
    {                                   //连接
//	        SYS_Message_Send(MSG_FARP_CNTGPRS, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_CNTGPRS;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
    }
    else if(gs_FarpVar.wkmd == 1)       //被动激活模式
    {                                   //断开连接
//	        SYS_Message_Send(MSG_FARP_DISGPRS, TASK_FARP_TKID);
        uint8 msg = MSG_FARP_DISGPRS;
        krhino_buf_queue_send(&gs_TKFarpQueue, &msg, 1);
        
    }
}


/*******************************************************************************
 * @function_name:  SYS_Farp_Task
 * @function_file:  farp.c
 * @描述: 远程通讯进程处理函数
 * 
 * 
 * @参数: 
 * 
 * @返回: 
 * @作者: yzy (2011-1-24)
 *-----------------------------------------------------------------------------
 * @修改人: 
 * @修改说明: 
 ******************************************************************************/
void SYS_Farp_Task(void * arg)
{
                                            //链表消息
    uint8 nmsg;                             //数字消息
    krhino_buf_queue_create(&gs_TKFarpQueue, "farp_queue",
                         gc_TKFarpQbuf, MSG_BUFF_LEN, MSG_BUFF_LEN);
    
//	    krhino_sem_create(&gs_FarpProc, "farp_proc_sem", 1);
    
    Farp_InitProc();
        
    SYS_MSG_Apply(TASK_FARP_TKID, MSG_CLS_TM);               //获取时间消息
    SYS_MSG_Apply(TASK_FARP_TKID, MSG_CLS_MD);               //获取时间消息
    Load_Para();
    for(;;)
    {
//获取进程消息
        krhino_buf_queue_recv(&gs_TKFarpQueue, RHINO_WAIT_FOREVER, g_TKFarpQ_buf_recv,
                                  &g_TKFarpQ_recv_size);

        switch(g_TKFarpQ_buf_recv[0])                        //根据消息分别处理
        {
            case MSG_SEC:
                Farp_SecondProc();
                break;

            case MSG_MIN:
                Farp_MinProc();
                break;

            case MSG_HOUR:
                Farp_HourProc();
                break;

            case MSG_DAY:
                Farp_DayProc();
                break;
#if (Modem_M72X_SMS_EN > 0)
            case MSG_SMRECV:                //短信数据
                Farp_SmgReadProc();
                break;
#endif                
            case MSG_RING:                  //振铃
                Farp_RingProc();
                break;
                
            case MSG_IP1DATA:               //IP数据
                Farp_IpDataReadProc();
                break;
                
            case MSG_FROMCLNDATA:          //表示TCP server收到来自客户端通道1的数据
                Farp_FromClientDataReadProc();
                break;
                
            case MSG_FARP_DISPPP:           //关闭PPP链接
                Farp_Close_PPP();
                break;
                
            case MSG_FARP_CNTPPP:           //建立PPP链接
                Farp_Creat_PPP();
                break;
                
            case MSG_FARP_CNTGPRS:          //连接GPRS
                Farp_WM_Connect();
                break;

            case MSG_FARP_DISGPRS:          //断开GPRS
                Farp_WM_DisCnt();
                break;
                
            case MSG_FARP_DISSERVER:           //关闭一个TCP Server
                Farp_Close_Server();
                break;
                
            case MSG_FARP_CNTSERVER:           //建立一个TCP Server
                Farp_Creat_Server();
                break;
                
            case MSG_FARP_DISFROMCLN1:           //关闭 收到的 一个客户端链接1
                Farp_Close_From_Client1();
                break;
           
            case MSG_FARP_DISFROMCLN2:           //关闭 收到的 一个客户端链接2
                Farp_Close_From_Client2();
                break;

            case MSG_FARP_RECVVALIDIP:      //IP收到有效数据
                Farp_RecvValidIpProc();
                break;
                
            case MSG_FARP_RECVVALIDSER:     //TCP Server 收到有效数据
                Farp_RecvValidTcpSerProc(); 
                break;
                
            case MSG_FARP_PRIOCNT:          //按优先级连接
                Farp_PrioConnect();
                break;

            case MSG_FARP_VAR:              //参数更新
                Farp_UpdateVar();
                break;

            case MSG_FARP_PARACHG:          //联网参数变更
                Farp_ParaChg();
                break;


            case MSG_LIVE:
				HB_RetLive(TASK_FARP_TKID);
                break;
        }
        
    }
}

/******************************************************************************
**远程通信进程块常量部分定义
//	******************************************************************************/
//	const TESTcbConst gs_TkFarp = 
//	{
//	    SYS_Farp_Task,
//	    TASK_FARP_TKID >> 3,                    //应用管理进程
//	    TASK_FARP_TKID,                         //进程编号
//	    TASK_FARP_TKID & 7,                     //优先级内进程编号位
//	    true,                                      //消息循环机制进程
//	};



const KTaskConst gs_TkFarp = 
{
    &gs_TKFarpHandle,
    SYS_Farp_Task,                           //无线猫进程
    gs_TKFarpStack,
    TASK_FARP_TKID,                           //进程编号
    true,                                    //消息循环机制进程
    TASK_FARP_STKL,
    "modem",
    &gs_TKFarpQueue,
};


